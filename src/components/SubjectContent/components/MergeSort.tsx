import mergeSortSplitting from 'assets/merge-sort-splitting.png?url';
import mergeSort1 from 'assets/merge-sort1.png?url';
import mergeSort2 from 'assets/merge-sort2.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const MERGE_SORT = `function mergeSort(array, left, right) {
  if (left < right) {
    const middle = Math.floor((left + right) / 2);

    mergeSort(array, left, middle); // сортируем левую половину
    mergeSort(array, middle + 1, right); // сортируем правую половину
    merge(array, left, middle, right); // объединяем отсортированные половины
  }

  return array;
}`;

const MERGE = `function merge(array, left, middle, right) {
  const leftLength = middle - left + 1;
  const rightLength = right - middle;

  const leftSubarray = new Array(leftLength);
  const rightSubarray = new Array(rightLength);

  for (let i = 0; i < leftLength; i++) {
    leftSubarray[i] = array[left + i];
  }

  for (let j = 0; j < rightLength; j++) {
    rightSubarray[j] = array[middle + 1 + j];
  }

  let i = 0;
  let j = 0;
  let k = left;

  while (i < leftLength && j < rightLength) {
    if (leftSubarray[i] <= rightSubarray[j]) {
      array[k] = leftSubarray[i];
      i++;
    } else {
      array[k] = rightSubarray[j];
      j++;
    }

    k++;
  }

  while (i < leftLength) {
    array[k] = leftSubarray[i];
    i++;
    k++;
  }

  while (j < rightLength) {
    array[k] = rightSubarray[j];
    j++;
    k++;
  }
}`;

const STABILITY_PROOF = `if (leftSubarray[i] <= rightSubarray[j]) {
  array[k] = leftSubarray[i];
  i++;
})`;

function MergeSort(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Концепция сортировки слиянием очень проста. Будем продолжать разбивать массив
        пополам, пока размер подмассивов не достигнет единицы, отсортируем их и объединим
        отсортированные массивы, в результате чего получится окончательный отсортированный
        массив. Мы будем использовать рекурсию для этого. Точнее, рекурсию с двумя
        ветвями.
      </p>
      <p className="mb-2">
        Возьмём массив из 5 элементов, например, <code>[3, 2, 4, 1, 6]</code>. Наша задача
        — отсортировать массив в порядке возрастания или неубывания, если у нас есть
        дубликаты. Мы будем разбивать массив следующим образом.
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Разбивка массива пополам"
          className="mx-auto"
          height="640"
          src={mergeSortSplitting}
          width="840"
        />
      </figure>
      <p className="mb-2">
        Как уже отмечалось, у нас есть две ветви. Давайте сначала поработаем над
        сортировкой и объединением левой ветви. Сначала нам необходимо достичь базового
        случая, после чего мы сможем начать сортировку и объединение массивов вместе,
        получив в результате <code>[2, 3, 4]</code>. Как только наша рекурсия достигнет
        базового случая, у нас появятся два подмассива: <code>[3]</code> и{' '}
        <code>[2]</code>. Нам нужен способ сравнить эти два элемента, чтобы знать, куда их
        поместить в исходный подмассив, то есть <code>[3, 2]</code>. Для этого создаются
        копии обоих подмассивов, и с помощью двух указателей значения сравниваются и
        помещаются в исходный подмассив в отсортированном порядке. Это можно увидеть в
        псевдокоде ниже.
      </p>
      <Code value={MERGE_SORT} />
      <h2 className="font-bold my-2">Визуализация и псевдокод</h2>
      <p className="mb-2">
        <strong>
          Рекурсивный вызов <code>mergeSort()</code>
        </strong>
      </p>
      <p className="mb-2">
        Используя рекурсию с двумя ветвями, мы решаем подзадачи обеих ветвей и «собираем»
        вместе решения подзадач, чтобы прийти к окончательному решению. Сначала мы
        отсортируем подмассив <code>[3, 2]</code> до <code>[2, 3]</code> — это часть{' '}
        <code>mergeSort(array, left, middle)</code>. Теперь мы можем перейти к сортировке{' '}
        <code>[4]</code>, что соответствует{' '}
        <code>mergeSort(array, middle + 1, right)</code>. Важно отметить
        последовательность выполнения вызовов. Вызов <code>merge()</code> не будет
        выполнен до тех пор, пока оба рекурсивных вызова <code>mergeSort()</code> не
        вернутся к текущему подмассиву. На первом изображении ниже показана сортировка и
        объединение левой половины. На втором изображении показана сортировка и
        объединение второй половины для получения окончательно отсортированного массива.
      </p>
      <img
        alt="Сортировка левой половины"
        className="mb-2"
        height="400"
        src={mergeSort1}
        width="1760"
      />
      <img alt="Сортировка правой половины" height="1340" src={mergeSort2} width="1739" />
      <p className="mb-2">
        <strong>
          Чтобы убедиться, что приведённые выше изображения не сбивают с толку, на них
          показано, как получается конечный массив, который является результирующим
          массивом. Изображения визуализируют то, что происходит внутри функции{' '}
          <code>merge()</code>.
        </strong>
      </p>
      <p className="mb-2">
        <strong>
          Функция <code>merge()</code> и три указателя
        </strong>
      </p>
      <p className="mb-2">
        Как видно на изображении выше, у нас есть три указателя: <code>k</code>,{' '}
        <code>j</code> и <code>i</code>.
      </p>
      <ul className="list-disc list-inside">
        <li>
          <code>k</code> отслеживает, где должен быть размещён следующий элемент в{' '}
          <code>array</code>.
        </li>
        <li>
          <code>i</code> указывает на элемент в левом подмассиве, который в данный момент
          сравнивается с элементом <code>j</code> в правом подмассиве.
        </li>
        <li>
          Один из <code>i</code> или <code>j</code> будет увеличиваться в зависимости от
          того, какой элемент меньше.
        </li>
        <li>
          <code>k</code> будет увеличиваться в любом случае, потому что внутри{' '}
          <code>array</code> будет помещен элемент независимо от того, какой из{' '}
          <code>i</code> или <code>j</code> увеличивается.
        </li>
      </ul>
      <p className="mb-2">
        Это ясно видно на изображении выше и показано в псевдокоде функции{' '}
        <code>merge()</code> ниже.
      </p>
      <Code value={MERGE} />
      <p className="mb-2">
        <strong>
          Хотя изображения демонстрируют только слияние конечного подмассива, рекурсия
          подразумевает, что слияние происходит на каждом уровне после сортировки
          массивов, потому что мы бы никогда не получили окончательный массив, если бы
          подмассивы не были отсортированы и объеденены.
        </strong>
      </p>
      <h2 className="font-bold my-2">Устойчивость</h2>
      <p className="mb-2">
        Сортировка слиянием является <strong>устойчивым</strong> алгоритмом, потому что
        если у нас есть пара дубликатов, скажем, <code>7</code>, то <code>7</code> в левом
        подмассиве всегда попадёт в объединённый массив раньше, чем <code>7</code> в
        правом подмассиве. Это связано с тем, что когда мы сравниваем <code>i-й</code>{' '}
        элемент в левом подмассиве с <code>j-м</code> элементом в правом подмассиве на
        предмет равенства, мы выбираем элемент в левом подмассиве, сохраняя относительный
        порядок. Вспомним следующий псевдокод из функции <code>merge()</code>.
      </p>
      <Code value={STABILITY_PROOF} />
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        Как же сортировка слиянием соотносится с сортировкой вставками? В худшем случае
        сортировка вставками составляет <i>O</i>(<i>n</i>
        <sup>2</sup>), когда сортировка слиянием составляет <i>O</i>(<i>n log n</i>) в
        худшем, среднем и лучшем случаях, что делает сортировку слиянием более
        эффективной. Единственный случай, когда сортировка вставками может быть
        предпочтительнее, это когда известно, что массив имеет мало элементов и уже
        отсортирован или почти отсортирован, поскольку при этом будет пропущена
        перестановка. Однако сортировка слиянием более эффективна с точки зрения времени,
        потому что, если мы не знаем размер входящих данных, сортировка вставками будет
        работать хуже, чем сортировка слиянием.
      </p>
    </>
  );
}

export default MergeSort;
