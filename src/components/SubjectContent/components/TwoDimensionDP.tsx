import twoDimensionDp1 from 'assets/two-dimension-dp1.png?url';
import twoDimensionDp2 from 'assets/two-dimension-dp2.png?url';
import twoDimensionDp3 from 'assets/two-dimension-dp3.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const BRUTE_FORCE = `function bruteForce(r, c, rows, cols) {
  if (r === rows || c === cols) {
    return 0;
  }

  if (r === rows - 1 && c === cols - 1) {
    return 1;
  }

  return bruteForce(r + 1, c, rows, cols) + bruteForce(r, c + 1, rows, cols);
}`;

const MEMOIZATION = `function memoization(r, c, rows, cols, cache) {
  if (r === rows || c === cols) {
    return 0;
  }

  if (cache[r][c] > 0) {
    return cache[r][c];
  }

  if (r === rows - 1 && c === cols - 1) {
    return 1;
  }

  cache[r][c] = memoization(r + 1, c, rows, cols, cache) + memoization(r, c + 1, rows, cols, cache);

  return cache[r][c];
}`;

const DP = `function dp(rows, cols) {
  let prevRow = new Array(cols).fill(0); 

  for (let i = rows - 1; i >= 0; i--) {
    let curRow = new Array(cols).fill(0);
    curRow[cols - 1] = 1;

    for (let j = cols - 2; j >= 0; j--) {
      curRow[j] = curRow[j + 1] + prevRow[j];
    }

    prevRow = curRow;
  }

  return prevRow[0];
}`;

function TwoDimensionDP(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Мы уже обсуждали одномерное динамическое программирование. Давайте теперь возьмём
        сетку (которую мы обсуждали ранее) и выясним, как мы можем применить к ней
        динамическое программирование. Для этого возьмём следующую задачу, знакомую нам по
        статьям про графы.
      </p>
      <p className="mb-2">
        <strong>
          Подсчитайте количество уникальных путей от верхнего левого угла до правого
          нижнего. Вам разрешено двигаться только вниз или вправо.
        </strong>
      </p>
      <p className="mb-2">
        Давайте примем во внимание следующую сетку, где нам разрешено двигаться только
        вниз или вправо. Единственный способ выйти за пределы — это если наш указатель{' '}
        <code>r</code> окажется на количестве строк, а указатель <code>c</code> — на
        количестве столбцов.
      </p>
      <img alt="Сетка" className="mb-2" height="340" src={twoDimensionDp1} width="340" />
      <h2 className="font-bold my-2">Подход методом грубой силы</h2>
      <p className="mb-2">
        Подход методом грубой силы, начиная с <code>0, 0</code>, будет выглядеть следующим
        образом, где синие стрелки обозначают все пути, которые мы можем пройти от
        заданной координаты. Чтобы вычислить уникальные пути от заданной координаты до
        пункта назначения, мы просто добавляем возвращаемое значение к текущему значению в
        нашей координате. Изображение ниже демонстрирует часть подхода грубой силы, но
        этого достаточно, чтобы увидеть, где он терпит неудачу. Зная то, что вы знаете о
        DP на данный момент, можете ли вы выяснить, где выполняется ненужная работа?
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Подсчёт уникальных путей методом грубой силы"
          className="mx-auto"
          height="980"
          src={twoDimensionDp2}
          width="980"
        />
      </figure>
      <Code value={BRUTE_FORCE} />
      <h2 className="font-bold my-2">Проблема</h2>
      <p className="mb-2">
        Проблема с этим подходом заключается в том, что, поскольку нам нужно идти вниз и
        вправо, чтобы вычислить значение по каждой отдельной координате, в конечном итоге
        нам придётся вычислять множество значений несколько раз, что является
        дорогостоящим, особенно при использовании подхода сверху. Сейчас это кажется
        тривиальным, учитывая размер сетки, но это будет намного менее эффективно, если у
        нас будет сетка размером, скажем, <code>100 * 100</code>.
      </p>
      <p className="mb-2">
        Давайте посмотрим, как мы можем решить эту проблему с помощью DP.
      </p>
      <h2 className="font-bold my-2">Подход динамического программирования</h2>
      <ul>
        <li className="mb-2">
          <p className="mb-2">
            <strong>Метод динамического программирования сверху</strong>
          </p>
          <p className="mb-2">
            Давайте теперь посмотрим, как мы можем использовать DP, чтобы сэкономить
            дополнительную работу, которую мы выполняем при решении методом грубой силы.
            Код будет выглядеть следующим образом:
          </p>
          <Code value={MEMOIZATION} />
          <p className="mb-2">
            Технически этот код очень похож на тот, который был при методе грубой силы. В
            этом случае мы вводим параметр кэша, который хранит количество уникальных
            путей от заданной координаты. Давайте теперь завершим остальную часть
            визуального представления, которое мы продемонстрировали ранее, только на этот
            раз используя подход DP.
          </p>
          <figure className="bg-white mb-2">
            <img
              alt="Подсчёт уникальных путей динамическим программированием"
              className="mx-auto"
              height="320"
              src={twoDimensionDp3}
              width="1330"
            />
          </figure>
          <p className="mb-2">
            На изображении выше мы находим пути для <code>1</code>-й строки{' '}
            <code>(1, 0)</code>, и это помогает нам найти пути для <code>0</code>-й
            строки. Обратите внимание, что на четвёртом шаге, когда мы хотим вычислить{' '}
            <code>(0, 1)</code>, нам не нужно вычислять <code>(1, 1)</code> снова,
            поскольку оно уже находится в нашем кэше. Это избавляет нас от тонны ненужной
            работы.
          </p>
        </li>
        <li className="mb-2">
          <p className="mb-2">
            <strong>Метод динамического программирования снизу</strong>
          </p>
          <p className="mb-2">
            При таком подходе мы можем начать снизу и двигаться вверх. Сложность по
            времени останется прежней, за исключением того, что это итеративный подход.
            Порядок, в котором мы выполняем эти вычисления, очень важен. Нам приходится
            вычислять эти значения справа налево, потому что мы можем получить
            возвращаемое значение только тогда, когда достигнем базового случая.
          </p>
          <p className="mb-2">
            На самом деле нам даже не нужна полная сетка для вычисления значений в любой
            заданной строке. Это означает, что для расчета значений <code>n</code>-й
            строки нам нужны только значения <code>n - 1</code> строки. Затем мы можем
            обновить нашу предыдущую строку, чтобы она стала текущей. Звучит знакомо? Мы
            использовали тот же подход в решении Фибоначчи!
          </p>
          <Code value={DP} />
          <p className="mb-2">
            Поскольку мы упомянули, что для вычисления значений в любой заданной строке
            нам нужна только предыдущая строка, мы можем инициализировать начальную
            строку, заполненную нулями, чтобы вычислить самую нижнюю строку. Наш первый
            цикл <code>for</code> уменьшает номер строки, и для каждого номера строки мы
            инициализируем строку, полную нулей, и присваиваем <code>1</code> самому
            правому столбцу, потому что это наше возвращаемое значение. Затем мы
            используем внутренний цикл <code>for</code>, чтобы просмотреть каждый столбец
            в строке и вычислить его значение так же, как мы продемонстрировали на
            изображениях ранее.
          </p>
        </li>
      </ul>
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        Это была лишь поверхностность, и задачи динамического программирования могут
        оказаться намного сложнее, чем то, что мы только что рассмотрели. Как всегда, эти
        основы помогут вам, по крайней мере, понять концепцию.
      </p>
    </>
  );
}

export default TwoDimensionDP;
