import knapsackIdea from 'assets/0-1-knapsack-idea.png?url';
import knapsackDp from 'assets/0-1-knapsack-dp.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const DFS = `function dfs(profit, weight, capacity) {
  return dfsHelper(0, profit, weight, capacity);
}

function dfsHelper(i, profit, weight, capacity) {
  if (i === profit.length) {
    return 0;
  }

  // Пропускает предмет i
  let maxProfit = dfsHelper(i + 1, profit, weight, capacity);

  // Включает предмет i
  const newCapacity = capacity - weight[i];

  if (newCapacity >= 0) {
    const p = profit[i] + dfsHelper(i + 1, profit, weight, newCapacity);
    // Вычисляет максимум
    maxProfit = Math.max(maxProfit, p);
  }

  return maxProfit;
}`;

const MEMOIZATION = `function memoization(profit, weight, capacity) {
  // Двумерный массив с N строк и M + 1 столбцов, инициализированный с -1
  const N = profit.length;
  const M = capacity;
  const cache = new Array();

  for (let row = 0; row < N; row++) {
    cache.push(new Array(M + 1).fill(-1));
  }

  return memoHelper(0, profit, weight, capacity, cache);
}

function memoHelper(i, profit, weight, capacity, cache) {
  if (i === profit.length) {
    return 0;
  }

  if (cache[i][capacity] !== -1) {
    return cache[i][capacity];
  }
  
  // Пропускает предмет i
  cache[i][capacity] = memoHelper(i + 1, profit, weight, capacity, cache);

  // Включает предмет i
  const newCapacity = capacity - weight[i];

  if (newCapacity >= 0) {
    const p = profit[i] + memoHelper(i + 1, profit, weight, newCapacity, cache);
    // Вычисляет максимум
    cache[i][capacity] = Math.max(cache[i][capacity], p);  
  }
  
  return cache[i][capacity];
}`;

const DP = `function dp(profit, weight, capacity) {
  const N = profit.length;
  const M = capacity;
  const dp = new Array();

  for (let row = 0; row < N; row++) {
    dp.push(new Array(M + 1).fill(0));
  }

  // Заполняет первый столбец и строку, чтобы сократить количество условий
  for (let i = 0; i < N; i++) {
    dp[i][0] = 0;
  }

  for (let c = 0; c <= M; c++) {
    if (weight[0] <= c) {
      dp[0][c] = profit[0];
    } 
  }

  for (let i = 1; i < N; i++) {
    for (let c = 1; c <= M; c++) {
      const skip = dp[i - 1][c];
      let include = 0;

      if (c - weight[i] >= 0) {
        include = profit[i] + dp[i - 1][c - weight[i]];
      }

      dp[i][c] = Math.max(include, skip);
    }
  }

  return dp[N - 1][M];
}`;

const OPTIMIZED_DP = `function optimizedDp(profit, weight, capacity) {
  const N = profit.length;
  const M = capacity;
  let dp = new Array(M + 1).fill(0);

  // Заполняет первую строку, чтобы сократить количество условий
  for (let c = 0; c <= M; c++) {
    if (weight[0] <= c) {
      dp[c] = profit[0];
    } 
  }

  for (let i = 1; i < N; i++) {
    const curRow = new Array(M + 1).fill(0);

    for (let c = 1; c <= M; c++) {
      const skip = dp[c];
      let include = 0;

      if (c - weight[i] >= 0) {
        include = profit[i] + dp[c - weight[i]];
      }

      curRow[c] = Math.max(include, skip);
    }

    dp = curRow;
  }

  return dp[M];
}`;

function Knapsack01(): ReactElement {
  return (
    <>
      <h2 className="font-bold my-2">Идея</h2>
      <p className="mb-2">
        Предположим, нам дана сумка/рюкзак фиксированной вместимости, а также вес
        некоторых предметов и ценность, которую мы получаем, решив положить этот предмет в
        сумку. Мы хотим максимизировать ценность, а также гарантировать, что вес всех
        предметов в нашем рюкзаке не превысит его вместимость. Причина, по которой этот
        алгоритм называется 0-1, заключается в том, что в каждой точке мы можем либо
        включить предмет, либо не включать его — бинарное решение.
      </p>
      <p className="mb-2">
        <strong>
          Учитывая список из N предметов и рюкзак ограниченной вместимости, верните
          максимальную общую ценность, которая может содержаться в рюкзаке. Ценность i-го
          предмета равна profit[i], а его вес равен weight[i]. Предположим, вы можете
          добавить каждый предмет в сумку не более одного раза.
        </strong>
      </p>
      <p className="mb-2">
        Вашим первым инстинктом может быть просто жадность и выбор предметов, имеющих
        наибольшую ценность. Однако таким образом мы не можем получить максимальную
        ценность, потому что вместимость может стать проблемой, так как предметы, имеющие
        самую высокую ценность, могут быть самыми тяжелыми. Итак, учитывая{' '}
        <code>profit = [4, 4, 7, 1]</code> и <code>weight = [5, 2, 3, 1]</code>, мы можем
        включить или исключить каждый предмет. Мы можем построить дерево решений, как
        показано ниже. <i>Вм</i> представляет вместимость нашей сумки в любой момент,
        цифры красного цвета представляют вес, а цифры синего цвета представляют общую
        ценность.
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Дерево решений задачи о рюкзаке 0-1"
          className="mx-auto"
          height="400"
          src={knapsackIdea}
          width="780"
        />
      </figure>
      <p className="mb-2">
        Глядя на изображение выше, вы можете заметить, что мы получаем наибольшую
        ценность, когда пропускаем первый предмет, но включаем все остальные предметы, что
        даёт общую ценность 12.
      </p>
      <p className="mb-2">
        <strong>
          В следующей статье мы более подробно остановимся на том, как работает дерево
          решений, но пока этого достаточно.
        </strong>
      </p>
      <h2 className="font-bold my-2">Реализация</h2>
      <p className="mb-2">
        Когда мы начнём думать о реализации кода, нашим базовым случаем будет{' '}
        <code>i === profit.length</code>. Это имеет смысл, потому что, если мы исчерпаем
        все предметы, возвращать будет нечего. Затем, как упоминалось ранее, мы можем либо
        пропустить предмет, либо включить его. Если мы пропустим предмет, нам не придётся
        беспокоиться о переполнении вместимости или о ценности.
      </p>
      <p className="mb-2">
        В случае, если мы решили включить предмет, мы должны рассчитать новую вместимость{' '}
        <strong>и</strong> включить этот предмет <i>только</i> в том случае, если
        включение этого предмета не приведёт к переполнению вместимости. Затем мы можем
        рассчитать ценность, пройдя вниз по этой ветви дерева решений, рекурсивный вызов
        которой будет каждый раз вызываться с новой, обновлённой вместимостью. Поскольку
        мы хотим максимизировать нашу ценность, мы можем взять максимум из двух
        рассчитанных ценностей, т. е. если наша <code>maxProfit</code> была получена путём
        пропуска <code>i</code> или включения <code>i</code>.
      </p>
      <Code value={DFS} />
      <p className="mb-2">
        Сложность по времени приведённого выше кода составляет 2
        <sup>
          <i>n</i>
        </sup>{' '}
        . Мы знаем, что 2
        <sup>
          <i>n</i>
        </sup>{' '}
        потенциально может быть очень большим, мы можем избежать дублирующейся работы.
        Напомним, для Фибоначчи мы вычисляли <code>F(2)</code> несколько раз. Возможно, вы
        уже догадались, что для оптимизации этого процесса можно использовать мемоизацию!
        На самом деле мы можем взять этот код и оптимизировать его так, чтобы довести его
        до сложности <i>O</i>(<i>n</i> ∗ <i>m</i>), где <i>m</i> — заданная нам
        вместимость.
      </p>
      <p className="mb-2">
        Мы можем использовать кэш, чтобы не пересчитывать значения. В функции{' '}
        <code>memoization</code> кэш представляет собой нашу двумерную сетку, в которой мы
        инициализируем все значения равными <code>-1</code>. Мы воспользуемся этим позже,
        чтобы помочь с нашим базовым случаем.
      </p>
      <Code value={MEMOIZATION} />
      <p className="mb-2">
        В нашей функции <code>memoHelper</code> у нас есть два базовых случая. Во-первых,
        если мы выйдем за пределы предметов, мы сможем вернуть <code>0</code>. Во-вторых,
        если наш кэш уже содержит значение в <code>cache[i][capacity]</code>, и это
        значение не <code>-1</code>, мы можем вернуть значение, хранящееся в кэше —
        ценность по этой позиции уже рассчитана.
      </p>
      <h2 className="font-bold my-2">Метод динамического программирования снизу</h2>
      <p className="mb-2">
        В этом случае у нас будет 9 столбцов и 4 строки, представляющие наше пространство
        решений. Каждая строка представляет каждый предмет, а каждый столбец представляет
        доступную вместимость. Теперь, предполагая, что все предметы имеют положительный
        вес, мы не можем включить какие-либо предметы в <code>0</code>-й столбец просто
        потому, что вес каждого предмета превышает вместимость <code>0</code> — нам просто
        не хватает места. Опять же, как и в случае с решением с мемоизацией, мы можем
        включить или пропустить этот предмет. Если мы решим пропустить этот предмет, его
        значение будет таким же, как <code>i-1</code>-я строка. Другими словами, значение
        слева.
      </p>
      <ul className="list-disc list-inside">
        <li className="ml-6 mb-2">
          Если мы находимся в строке и столбце, где вес предмета (изображенного строкой)
          превышает вместимость (изображенную столбцом), мы получаем его значение по{' '}
          <code>dp[i - 1][c]</code>, что означает подъём на одну строку вверх.
        </li>
        <li className="ml-6 mb-2">
          Если мы находимся в строке и столбце, вместимости которых достаточно для
          размещения предмета, мы получаем значение этой ячейки, беря ценность, связанную
          с этим предметом, и добавляя ее к <code>dp[i - 1][c - weight[i]]</code>, что
          означает переход на одну строку вверх, а <code>c - weight[i]</code> — влево, где{' '}
          <code>c</code> — текущая вместимость, а <code>weight[i]</code> — вес текущего
          предмета. Это означает движение вверх по диагонали.
        </li>
      </ul>
      <p className="mb-2">
        В конце концов мы можем вернуть значение в правой нижней ячейке. Вот как это будет
        выглядеть визуализировано.
      </p>
      <img alt="Сетка" className="mb-2" height="300" src={knapsackDp} width="640" />
      <Code value={DP} />
      <h2 className="font-bold my-2">(небольшая) оптимизация памяти</h2>
      <p className="mb-2">
        Обратите внимание, что в предыдущем решении мы постоянно храним в памяти всю
        сетку. Однако реальность такова, что нам нужно только две строки в памяти
        одновременно.
      </p>
      <Code value={OPTIMIZED_DP} />
      <h2 className="font-bold my-2">Сложность по времени и памяти</h2>
      <p className="mb-2">
        Как упоминалось ранее, метод динамического программирования снизу снижает
        сложность по времени до <i>O</i>(<i>n</i> ∗ <i>m</i>), где <i>n</i> — количество
        предметов, а <i>m</i> — вместимость нашего рюкзака. Это большое улучшение по
        сравнению с 2
        <sup>
          <i>n</i>
        </sup>
        .
      </p>
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        Вопросы по динамическому программированию поначалу могут быть чрезвычайно трудными
        и требуют много практики. Недостаточно смотреть на код, главное — решать проблемы
        самостоятельно.
      </p>
    </>
  );
}

export default Knapsack01;
