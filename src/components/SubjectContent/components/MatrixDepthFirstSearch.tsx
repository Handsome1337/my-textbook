import matrixDepthFirstSearch1 from 'assets/matrix-depth-first-search1.png?url';
import matrixDepthFirstSearch2 from 'assets/matrix-depth-first-search2.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const GRAPH = `const matrix = [[0, 0, 0, 0],
               [1, 1, 0, 0],
               [0, 0, 0, 1],
               [0, 1, 0, 0]];`;

const DFS = `function dfs(grid, r, c, visit) {
  const ROWS = grid.length;
  const COLS = grid[0].length;

  if (Math.min(r, c) < 0 || r === ROWS || c === COLS ||
    visit.has(\`\${r}-\${c}\`) || grid[r][c] === 1) {
    return 0;
  }
  
  if (r === ROWS - 1 && c === COLS - 1) {
    return 1;
  }
  
  visit.add(\`\${r}-\${c}\`);

  let count = 0;
  count += dfs(grid, r + 1, c, visit);
  count += dfs(grid, r - 1, c, visit);
  count += dfs(grid, r, c + 1, visit);
  count += dfs(grid, r, c - 1, visit);

  visit.delete(\`\${r}-\${c}\`);
  return count;
}`;

function MatrixDepthFirstSearch(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Как нам применить поиск в глубину к графам? Лучше всего показать это на примере.
      </p>
      <p className="mb-2">Предположим, нам необходимо решить следующую задачу:</p>
      <p className="mb-2">
        <strong>
          Подсчитайте уникальные пути от левого верхнего угла до правого нижнего. Один
          путь может проходить только через нули и не может посещать одну и ту же ячейку
          более одного раза.
        </strong>
      </p>
      <Code value={GRAPH} />
      <p className="mb-2">
        В этой задаче всё зависит от выбора. Вы можете подумать, что это похоже на
        бэктрекинг, и будете правы. Ранее мы упоминали, что DFS рекурсивен по своей
        природе, и для решения этой задачи мы будем использовать рекурсию. Во-первых, нам
        нужно подумать о нашем базовом случае(ах). Что ж, мы знаем, что можем двигаться во
        всех четырёх направлениях, кроме диагонального. Это означает, что если мы выйдем
        за пределы, мы можем вернуть ноль.
      </p>
      <p className="mb-2">
        Мы знаем, что это будет метод грубой силы, DFS с бэктрекингом, поскольку в любой
        точке нашего пути у нас может не быть допустимого способа добраться до правого
        нижнего угла, и в этом случае нам придётся вернуться.
      </p>
      <p className="mb-2">
        Для начала давайте определимся с нашими базовыми случаями. Поскольку мы пытаемся
        найти количество уникальных путей, нам нужно вести подсчёт допустимых путей из
        каждой вершины.
      </p>
      <h2 className="font-bold my-2">Базовые случаи</h2>
      <ol className="list-decimal list-inside">
        <li className="mb-2">
          <strong>Уникального пути не существует</strong>
          <p className="mb-2">
            Поскольку нам разрешено двигаться во всех четырёх направлениях, вполне
            возможно, что во время нашего обхода мы в конечном итоге выйдем за пределы
            матрицы. Это означает, что либо наш столбец <code>c</code>, либо наша строка{' '}
            <code>r</code> становятся отрицательными или выходят за пределы длины нашей
            матрицы. Не имеет значения, что из <code>r</code> и <code>c</code> выходит за
            пределы, потому что для выполнения поиска нам нужен действительный{' '}
            <code>c</code> <strong>И</strong> действительный <code>r</code>. Мы не можем
            выполнить поиск по <code>matrix[-1][3]</code>.
          </p>
          <p className="mb-2">
            Если мы уже посетили координату или текущая координата равна <code>1</code>,
            то допустимого пути через эту координату не существует.
          </p>
          <p className="mb-2">
            Поэтому, поскольку во всех вышеупомянутых случаях допустимого пути не
            существует, мы вернём <code>0</code>, что означает отсутствие уникального
            пути. Скоро мы увидим это в нашем коде.
          </p>
        </li>
        <li>
          <strong>Уникальный путь существует</strong>
          <p className="mb-2">
            Если мы не вернули <code>0</code> из первого случая, и мы достигли самого
            правого столбца и самой нижней строки, это должно быть тот случай, когда мы
            нашли действительный путь. Помните, что наше определение допустимого пути —
            это существование пути от <code>matrix[0][0]</code> до{' '}
            <code>matrix[3][3]</code>. Теперь мы можем вернуть <code>1</code>, и это
            увеличит наш счётчик количества уникальных путей.
          </p>
        </li>
      </ol>
      <h2 className="font-bold my-2">Реализация</h2>
      <p className="mb-2">
        Чтобы гарантировать, что мы не посетим координату более одного раза, мы добавляем
        её в глобальный HashSet после посещения.
      </p>
      <p className="mb-2">
        Затем по любой заданной координате мы можем рекурсивно выполнить наш DFS для{' '}
        <code>r + 1</code>, <code>r - 1</code>, <code>c + 1</code> и <code>c - 1</code>.
        Если наш рекурсивный вызов вернет <code>1</code>, наш счётчик будет увеличен, и
        если он вернёт <code>0</code>, добавление его к счётчику не будет иметь никакого
        значения.
      </p>
      <p className="mb-2">
        При каждом рекурсивном вызове мы можем удалить все строки и столбцы, которые
        привели нас к недопустимому пути. Таким образом, мы можем гарантировать, что
        посетим их снова, но выберем другое направление и проверим, существует ли
        действительный путь с этого направления.
      </p>
      <p className="mb-2">
        В приведённом ниже коде мы настроили вышеупомянутые базовые случаи. Затем мы
        добавляем текущую строку и столбец в наш <code>Set</code>. Наш счётчик
        инициализируется с <code>0</code>, потому что нам нужно отслеживать все возможные
        уникальные пути к месту назначения в любой заданной вершине. Как только наши
        рекурсивные вызовы вернутся, мы сможем удалить посещённые вершины из нашего{' '}
        <code>Set</code>. Опять же, это потому, что они могут быть частью другого
        уникального пути, просто из другого источника. Итак, когда мы вернёмся назад, мы
        сможем посетить их снова.
      </p>
      <Code value={DFS} />
      <p className="mb-2">
        Чтобы визуализировать вышеизложенное в нашей матрице, мы можем разбить наш
        алгоритм на поиск исходного уникального пути, а затем вернуться назад, чтобы найти
        другой потенциально уникальный путь.
      </p>
      <ol className="list-decimal list-inside">
        <li className="mb-2">
          <strong>Найдём первый уникальный путь</strong>
          <figure className="bg-white mb-2">
            <img
              alt="Поиск первого уникального пути"
              className="mx-auto"
              height="1000"
              src={matrixDepthFirstSearch1}
              width="1010"
            />
          </figure>
        </li>
        <li>
          <strong>Возврат назад, чтобы найти другой потенциально уникальный путь</strong>
          <p className="mb-2">
            <strong>
              Красная пунктирная линия представляет ещё один уникальный путь, достигнутый
              из <code>matrix[0][3]</code>.
            </strong>
          </p>
          <figure className="bg-white mb-2">
            <img
              alt="Возврат для поиска другого потенциального уникального пути"
              className="mx-auto"
              height="1340"
              src={matrixDepthFirstSearch2}
              width="1010"
            />
          </figure>
        </li>
      </ol>
      <p className="mb-2">
        Наша функция возвращает <code>2</code>, обозначая, что существуют <code>2</code>{' '}
        уникальных пути от <code>(0,0)</code> до <code>(3,3)</code>.
      </p>
      <h2 className="font-bold my-2">Сложность по времени</h2>
      <p className="mb-2">
        К настоящему моменту мы знаем, что рассматриваем только худший случай. В худшем
        случае нам может потребоваться просмотреть каждую строку и столбец. По каждой
        координате мы можем двигаться во всех четырех направлениях. Каждая из координат,
        достигнутых при движении в каждом из этих четырех направлений, также сможет
        перемещаться вверх, вниз, влево или вправо. У нас есть четыре варианта из каждой
        позиции. Если мы хотим создать из этого дерево решений, каждый узел будет иметь не
        более четырех дочерних элементов. Дерево имеет коэффициент ветвления{' '}
        <code>4</code>, а высота дерева равна размеру матрицы, которая равна всего{' '}
        <code>
          <i>n</i> ∗ <i>m</i>
        </code>
        , где{' '}
        <code>
          <i>n</i>
        </code>{' '}
        — количество строк, а{' '}
        <code>
          <i>m</i>
        </code>{' '}
        это количество столбцов.
      </p>
      <p className="mb-2">
        Следовательно, мы получаем <code>4</code>
        <sup>
          <i>nm</i>
        </sup>
        .
      </p>
      <p className="mb-2">
        Сложностью по памяти будет весь стек вызовов, поскольку он рекурсивный.
        Следовательно, она составит <i>O</i>(<i>n</i> ∗ <i>m</i>).
      </p>
    </>
  );
}

export default MatrixDepthFirstSearch;
