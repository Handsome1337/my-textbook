import binaryHeap from 'assets/binary-heap.png?url';
import binaryHeapArray from 'assets/binary-heap-array.png?url';
import binaryHeapParentAndChildren from 'assets/binary-heap-parent-and-children.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const HEAP = `class Heap {
    constructor() {
        this.heap = [];
        this.heap.push(0);
    }
}`;

function HeapProperties(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Куча (heap) — это специализированная древовидная структура данных, которая
        представляет собой полное бинарное дерево. Куча реализует абстрактный тип данных,
        называемый очередью с приоритетом, но иногда «куча» и «очередь с приоритетом»
        используются как взаимозаменяемые термины.
      </p>
      <p className="mb-2">
        Мы уже узнали, что очереди работают по принципу «первый пришёл — первый вышел», но
        в очереди с приоритетом значения удаляются в зависимости от заданного приоритета.
        Первым удаляется элемент с наивысшим приоритетом.
      </p>
      <h2 className="font-bold my-2">Два типа кучи</h2>
      <ol className="list-decimal list-inside mb-2">
        <li>Min Heap</li>
        <li>Max Heap</li>
      </ol>
      <p className="mb-2">
        <strong>Min heaps</strong> имеют наименьшее значение в корневом узле, а при
        удалении наименьшее значение имеет наивысший приоритет.
      </p>
      <p className="mb-2">
        <strong>Max heaps</strong> имеют наибольшее значение в корневом узле, а при
        удалении наибольшее значение имеет наивысший приоритет.
      </p>
      <p className="mb-2">
        В этой статье мы сосредоточимся на min heap, но реализация для max heap точно
        такая же, за исключением того, что вы отдаёте приоритет максимальному значению
        вместо минимального.
      </p>
      <h2 className="font-bold my-2">Свойства кучи</h2>
      <p className="mb-2">
        Чтобы бинарное дерево можно было назвать кучей, оно должно удовлетворять следующим
        свойствам:
      </p>
      <ol className="list-decimal list-inside">
        <li className="mb-2">
          <strong>Свойство структуры</strong>
          <p>
            Бинарная куча — это бинарное дерево, которое представляет собой{' '}
            <strong>полное бинарное дерево</strong>, в котором каждый уровень дерева
            заполнен полностью, за исключением узлов самого нижнего уровня, которые
            заполняются последовательно слева направо.
          </p>
        </li>
        <li className="mb-2">
          <strong>Свойство порядка</strong>
          <p className="mb-2">
            Свойство порядка для min heap заключается в том, что все потомки должны быть
            больше, чем их предок. Другими словами, если у нас есть дерево с корнем{' '}
            <code>y</code>, каждый узел в правом и левом поддереве должен быть больше или
            равен <code>y</code>. Это рекурсивное свойство, как в бинарных деревьях
            поиска.
          </p>
          <p>
            В max heap каждый узел в правом и левом поддереве меньше или равен{' '}
            <code>y</code>.
          </p>
        </li>
      </ol>
      <p className="mb-2">На следующем изображении показана бинарная куча.</p>
      <img alt="Бинарная куча" height="440" src={binaryHeap} width="509" />
      <h2 className="font-bold my-2">Реализация</h2>
      <p className="mb-2">
        Бинарные кучи рисуются с использованием древовидной структуры данных, но внутри
        они реализуются с использованием массивов. Давайте покажем, как мы можем это
        сделать, используя данную бинарную кучу:{' '}
        <code>
          [14, 19, 16, 21, 26, 19, 68, 65, 30, null, null, null, null, null, null]
        </code>
        .
      </p>
      <p className="mb-2">
        Мы возьмем массив размером{' '}
        <code>
          <i>n</i> + 1
        </code>
        , где <i>n</i> — количество узлов в нашей бинарной куче. Скоро это обретёт смысл.
        Мы будем посещать наши узлы в том же порядке, как мы посещаем узлы при поиске в
        ширину — уровень за уровнем, слева направо. Мы вставим их в наш массив
        последовательно. Однако мы начнём их заполнять с индекса <code>1</code>, а не с{' '}
        <code>0</code>, по причинам, которые мы скоро обсудим.
      </p>
      <p className="mb-2">
        После заполнения нашего массива он будет выглядеть следующим образом:
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Заполнение кучи (массива)"
          className="mx-auto"
          height="420"
          src={binaryHeapArray}
          width="1040"
        />
      </figure>
      <p className="mb-2">
        Причина, по которой мы начинаем заполнять наш массив с индекса <code>1</code>,
        заключается в том, что это помогает нам определить индекс, в котором находится
        левый дочерний, правый дочерний или родительский узел узла. Поскольку бинарные
        кучи представляют собой полные бинарные деревья, для указателей не требуется
        места. Вместо этого левый дочерний, правый дочерний и родительский узел можно
        вычислить с помощью следующих формул, где <i>i</i> — индекс данного узла.
      </p>
      <p className="flex flex-col mb-2">
        <code>
          <strong>левый дочерний узел</strong> = 2 ∗ <i>i</i>
        </code>
        <code>
          <strong>правый дочерний узел</strong> = 2 ∗ <i>i</i> + 1
        </code>
        <code>
          <strong>родительский узел</strong> = <i>i</i> / 2
        </code>
      </p>
      <p className="mb-2">
        Теперь предположим, что мы хотим найти указанные выше свойства узла{' '}
        <code>19</code>. На следующем изображении показано, как использование формул
        помогает нам их понять. Число внутри круга в каждом узле дерева — это значение,
        хранящееся в этом узле. Число над узлом (синим цветом) — это соответствующий
        индекс в массиве. Важно отметить, что эти формулы работают только в том случае,
        если дерево является полным бинарным деревом. Теперь мы также можем понять, почему
        мы начинаем с индекса <code>1</code>. Предположим, мы хотели найти левый и правый
        дочерний узел <code>14</code>, а <code>14</code> находился в <code>0</code>. Ну,
        любое число, умноженное на <code>0</code> это <code>0</code>, и сообщит нам, что
        левый дочерний элемент находится по индексу <code>0</code>, что, конечно, не так.
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Поиск родительского и дочерних узлов в бинарной куче"
          className="mx-auto"
          height="420"
          src={binaryHeapParentAndChildren}
          width="1040"
        />
      </figure>
      <p className="mb-2">
        <strong>
          Всякий раз, когда с кучей выполняются какие-либо операции, например удаление или
          добавление, мы должны убедиться, что свойства min heap удовлетворены и три
          вышеупомянутые формулы по-прежнему действительны. Мы обсудим это в следующей
          статье.
        </strong>
      </p>
      <p className="mb-2">Ниже приведен код реализации кучи.</p>
      <Code value={HEAP} />
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        Глядя на свойства max heap и min heap, можно сказать, что если задача требует от
        нас найти минимум или максимум, куча является жизнеспособным вариантом. Посмотрим,
        насколько он эффективен, когда дело доходит до операций удаления и добавления.
      </p>
    </>
  );
}

export default HeapProperties;
