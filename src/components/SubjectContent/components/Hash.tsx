import { Code } from 'components/Code';
import hashImplementation from 'assets/hash-implementation.png?url';
import type { ReactElement } from 'react';

const HASH_MAP_INSERT = `hashmap["Александр"] = "Дрожжино";
hashmap["Михаил"] = "Москва";
hashmap["Джексон"] = "Мценск";`;

function Hash(): ReactElement {
  return (
    <>
      <p className="mb-2">
        В этой статье речь пойдёт о хеш-картах. Примеры и задачи в Моём справочнике
        пишутся на <code>JavaScript</code>, данная статья в большей степени актуальна для
        других языков программирования.
      </p>
      <p className="mb-2">
        Хеш-карты «под капотом» чаще всего реализуются с помощью массивов. Хеш-карта может
        иметь нулевой размер, но массив изначально не будет иметь нулевой размер.
      </p>
      <p className="mb-2">
        Предположим, что мы хотим заполнить этот массив следующими парами ключ/значение:
      </p>
      <Code value={HASH_MAP_INSERT} />
      <p className="mb-2">
        Для этого нам необходимо познакомиться с <strong>хешированием</strong> и{' '}
        <strong>хеш-функциями</strong>. Хеш-функция принимает ключ (в данном случае
        строку) и конвертирует его в число. Одна и та же строка всегда будет давать одно и
        то же число. Используя это число, можно определить место, в котором мы хотим
        сохранить нашу пару ключ/значение.
      </p>
      <h2 className="font-bold mb-2">Вставка и хеширование</h2>
      <p className="mb-2">
        Возьмем <code>&quot;Александр&quot;</code> для примера. Наша хеш-функция возьмёт
        каждый символ строки и получит его ASCII-код (я буду использовать псевдозначения
        для простоты). Затем она суммирует ASCII-коды, чтобы определить, где строка должна
        оказаться в массиве. Однако, поскольку это может быть огромное число и оно легко
        может выйти за размеры массива, мы можем использовать оператор остатка от деления{' '}
        <code>%</code>. Представим, что сумма ASCII-кодов всех символов{' '}
        <code>&quot;Александр&quot;</code> равна 25. Чтобы определить расположение строки
        в массиве, мы можем использовать формулу:{' '}
        <strong>
          сумма ASCII-кодов <code>%</code> размер массива
        </strong>
        . В нашем случае размер массива равен 2. Таким образом, <code>25 % 2</code>{' '}
        равняется <strong>1</strong>, по этому индексу мы будем хранить первую пару
        ключ/значение. Этот процесс также иногда называют <strong>прехешированием</strong>
        .
      </p>
      <p className="mb-2">
        Из-за того, что размер нашего массива равен всего лишь 2, вполне вероятно, что
        другая пара ключ/значение приведёт к такому же индексу массива, когда мы возьмём
        остаток. Это называется коллизией, коллизии очень распространены. Есть способы
        попытаться свести к минимуму коллизии, но они совершенно неизбежны.
      </p>
      <p className="mb-2">
        Чтобы гарантировать, что каждая пара ключ/значение найдёт свободное место, мы
        будем отслеживать размер массива и количество фактически заполненных индексов.
        Когда хеш-карта станет наполовину заполненой (половина индексов в массиве занята),
        мы будем удваивать размер массива: <strong>размер массива * 2</strong>. В данном
        случае мы имеем размер 2, и посколько добавление{' '}
        <code>&quot;Александр&quot;: &quot;Дрожжино&quot;</code> приведёт к заполнению
        карты наполовину, мы удвоим её размер перед выполнением следующей вставки.{' '}
        <strong>Это гарантирует, что мы минимизируем коллизии перед вставкой.</strong>
      </p>
      <p className="mb-2">
        Как только мы изменили размер, мы выполняем операцию, называемую{' '}
        <strong>рехешированием</strong>. Это необходимо, поскольку размер массива
        изменился. Рехеширование пересчитывает положение всех элементов, которые уже
        существуют в хеш-карте. Мы вставили <code>&quot;Александр&quot;</code> по индексу{' '}
        <strong>1</strong>. В данном случае после удвоения размера массива новая позиция{' '}
        <code>&quot;Александр&quot;</code> оказывается по индексу <strong>1</strong>,
        поэтому нам не нужно её обновлять. Однако, если новая позиция{' '}
        <code>&quot;Александр&quot;</code> была бы по индексу 2, нам нужно было бы
        переместить пару ключ/значение.
      </p>
      <p className="mb-2">
        <strong>
          Нам необходимо выполнять рехеширование, если мы хотим поддерживать сложность по
          времени <i>O</i>(1) для наших операций. Мы начали с массива с размером 2.
          Допустим, мы хотели вставить 10000 пар ключ/значение в массив. Когда мы хотим
          найти <code>&quot;Александр&quot;</code>, мы вычисляем позицию, используя новый
          размер, и <code>&quot;Александр&quot;</code> может больше не быть в этой
          позиции.
        </strong>
      </p>
      <p className="mb-2">
        Представим, что конвертирование <code>&quot;Михаил&quot;</code> в число приводит к
        27.{' '}
        <strong>
          <code>27 % 4 = 3</code>
        </strong>
        , что означает <code>&quot;Михаил&quot;: &quot;Москва&quot;</code> окажется в
        массиве по 3 индексу. Теперь мы удвоим размер, он станет равным 8.
      </p>
      <h2 className="font-bold mb-2">Коллизии</h2>
      <p className="mb-2">
        Предположим, что конвертирование <code>&quot;Джексон&quot;</code> в число приводит
        к 33.{' '}
        <strong>
          <code>33 % 8 = 1</code>
        </strong>
        . Это коллизия, поскольку Александр уже находится по индексу 1. Как решить эту
        проблему? Мы можем продолжать увеличивать размер массива, пока не найдём свободное
        место для <code>&quot;Джексон&quot;</code>, однако это гигансткий расход памяти.
      </p>
      <p className="mb-2">Есть два распространенных способа преодоления коллизий:</p>
      <ol className="list-decimal list-inside">
        <li>
          <strong>Метод цепочек</strong>
          <p className="mb-2">
            Метод цепочек решает коллизии путём объединения элементов в узлы связного
            списка, таким образом несколько пар ключ/значение могут храниться по одному
            индексу.
          </p>
          <p className="mb-2">
            Поскольку Александр и Джексон принадлежат одному и тому же индексу, мы можем
            хранить их как объект связного списка. В этом случае сложность по времени
            сводится к <i>O</i>(<i>n</i>) для поиска, вставки и удаления. Любые будущие
            ключи, принадлежащие тому же индексу, будут храниться как узел в цепочке
            связного списка.
          </p>
        </li>
        <li>
          <strong>Открытая адресация</strong>
          <p className="mb-2">
            Идея открытой адресации состоит в том, чтобы найти следующий доступный слот,
            чтобы мы не хранили более одной пары ключ/значение по одному индексу. В
            сравнении с методом цепочек, открытая адресация более эффективна при небольшом
            количестве коллизий. Ограничением здесь является то, что общее количество
            записей в хеш-карте ограничено размером массива.
          </p>
        </li>
      </ol>
      <img alt="Реализация хеша" height="800" src={hashImplementation} width="1600" />
    </>
  );
}

export default Hash;
