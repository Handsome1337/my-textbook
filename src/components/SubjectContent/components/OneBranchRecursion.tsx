import factorial1 from 'assets/factorial1.png?url';
import factorial2 from 'assets/factorial2.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const RECURSIVE_FACTORIAL = `function factorial(n) {
  if (n <= 1) {
    return 1;
  }

  return n * factorial(n - 1);
}`;

const ITERATIVE_FACTORIAL = `let n = 5;
let result = 1;

while (n > 1) {
  result *= n;
  n--;
}`;

function OneBranchRecursion(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Рекурсия — это когда функция вызывает саму себя с как правило меньшим входным
        значением. Когда итеративная функция будет использовать циклы <code>for</code> и{' '}
        <code>while</code>, рекурсивная функция будет вызывать саму себя до тех пор, пока
        не будет достигнут базовый случай.
      </p>
      <p className="mb-2">
        <strong>Рекурсивные функции состоят из двух частей:</strong>
      </p>
      <ul className="list-disc list-inside mb-2">
        <li>
          <strong>Базовый случай</strong>
        </li>
        <li>
          <strong>Функция, вызывающая саму себя с другим входным значением</strong>
        </li>
      </ul>
      <p className="mb-2">
        <strong>
          Существует два типа рекурсии: с одной ветвью и с двумя ветвями. Сначала
          рассмотрим рекурсию с одной ветвью.
        </strong>
      </p>
      <p className="mb-2">
        Рекурсию лучше всего объяснить на примере. Возьмём <i>n</i> факториал из
        математики, формула для которого:{' '}
        <code>
          <i>n</i>! = <i>n</i> * (<i>n</i> - 1) * (<i>n</i> - 2) * ...1
        </code>
        . <i>n</i>! — это всего лишь краткий способ представления совокупного произведения
        всех чисел от <i>n</i> до 1. Более короткий способ записи этого будет следующий:{' '}
        <code>
          <i>n</i>! = <i>n</i> * (<i>n</i> - 1)!
        </code>
        , то есть <code>5! = 5 * 4!</code>. Это показано на изображении и псевдокоде ниже.
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Представление факториала"
          className="mx-auto"
          height="780"
          src={factorial1}
          width="200"
        />
      </figure>
      <Code value={RECURSIVE_FACTORIAL} />
      <p className="mb-2">
        В последней строке в операторе <code>return</code> функция вызывает саму себя с
        другим входным значением. Давайте проанализируем это. У нас есть две части:{' '}
        <strong>базовый случай</strong> и <strong>вызывающая саму себя функция</strong>.
      </p>
      <p className="mb-2">
        Когда код достигает последней строки с переданным значением 5, мы получаем{' '}
        <code>5 * factorial(4)</code>, что снова начинает выполнение функции, только
        теперь со значением 4, после чего мы получаем <code>4 * factorial(3)</code>, и
        затем <code>3 * factorial(2)</code>, и, наконец, <code>2 * factorial(1)</code>,
        после чего достигается базовый случай.
      </p>
      <p className="mb-2">
        Но что происходит, когда достигается базовый случай? Когда функция вызывается с
        переданным значением <code>1</code>, возвращается <code>1</code>, и теперь это
        значение можно умножить на 2, что приведёт к <code>2</code>, что будет ответом для{' '}
        <code>2!</code>. Пока мы решили только первую подзадачу. Теперь мы вычисляем{' '}
        <code>3 * factorial(2)</code>, в результате чего получаем <code>6</code>, затем{' '}
        <code>4 * factorial(3)</code>, получая <code>24</code>, и, наконец,{' '}
        <code>5 * factorial(4)</code>, получая <code>120</code> — окончательный ответ для{' '}
        <code>5!</code>. <strong>Самая важная часть</strong> заключается в том, что когда
        мы достигаем базового случая, мы возвращаемся «вверх» по дереву рекурсии, потому
        что теперь нам нужно «собрать» воедино ответы на наши подзадачи, чтобы прийти к
        окончательному решению.
      </p>
      <p className="mb-2">Этот процесс визуализирован ниже.</p>
      <figure className="bg-white mb-2">
        <img
          alt="Расчёт факториала"
          className="mx-auto"
          height="780"
          src={factorial2}
          width="1060"
        />
      </figure>
      <p className="mb-2">
        <strong>
          Как уже отмечалось, мы взяли исходную задачу <code>factorial(5)</code> и разбили
          её на более мелкие подзадачи, и, объединив ответы на эти подзадачи, мы смогли
          решить исходную задачу. Важно отметить, что если в рекурсии нет базового случая,
          последняя строка будет выполняться вечно, что приведёт к переполнению стека!
        </strong>
      </p>
      <h2 className="font-bold my-2">Анализ сложности по времени и памяти</h2>
      <p className="mb-2">
        Всего выполняется <i>n</i> вызовов функции <code>factorial</code>, в результате
        чего сложность по времени составляет <i>O</i>(<i>n</i>). Кроме того, сложность по
        памяти также будет равна <i>O</i>(<i>n</i>). Поскольку выполняется <i>n</i>{' '}
        рекурсивных вызовов, получается <i>n</i> стеков, что приводит к сложности по
        памяти <i>O</i>(<i>n</i>).
      </p>
      <h2 className="font-bold my-2">Циклы и рекурсия</h2>
      <p className="mb-2">
        Любой рекурсивный алгоритм можно написать итеративно, и наоборот. Итеративная
        реализация вычисления факторила будет выглядеть так:
      </p>
      <Code value={ITERATIVE_FACTORIAL} />
      <p className="mb-2">
        В итеративном случае мы сохраняем наш ответ в переменноё с именем{' '}
        <code>result</code> и уменьшаем <code>n</code> до тех пор, пока <i>n</i> не станет
        равным <code>1</code>.
      </p>
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        Рекурсия станет очень полезной, когда мы доберёмся до деревьев, поскольку её можно
        легко использовать для поиска в глубину.
      </p>
    </>
  );
}

export default OneBranchRecursion;
