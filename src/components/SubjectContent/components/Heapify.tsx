import heapify from 'assets/heapify.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const HEAPIFY = `heapify(array) {
  // 0-я позиция перемещается в конец
  array.push(array[0]);

  this.heap = array;

  let cur = Math.floor((this.heap.length - 1) / 2);

  while (cur > 0) {
    // Спускает вниз
    let i = cur;

    while (2 * i < this.heap.length) {
      if (2 * i + 1 < this.heap.length
        && this.heap[2 * i + 1] < this.heap[2 * i]
        && this.heap[i] > this.heap[2 * i + 1]
      ) {
        // меняет с правым дочерним элементом
        [this.heap[i], this.heap[2 * i + 1]] = [this.heap[2 * i + 1], this.heap[i]];
        i = 2 * i + 1;
      } else if (this.heap[i] > this.heap[2 * i]) {
        // меняет с левым дочерним элементом     
        [this.heap[i], this.heap[2 * i]] = [this.heap[2 * i], this.heap[i]];
        i = 2 * i;
      } else {
        break;
      }
    }

    cur--;
  }

  return;
}`;

function Heapify(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Напомним, что сложность по времени построения бинарного дерева поиска из <i>n</i>{' '}
        элементов равна <i>O</i>(<i>n log n</i>). Если мы построим кучу размера <i>n</i> с
        помощью операции push для каждого элемента, это также будет выполняться за время{' '}
        <i>O</i>(<i>n log n</i>). Но на самом деле существует более эффективный алгоритм,
        известный как <i>Heapify</i>, который позволяет нам выполнить эту операцию за
        время <i>O</i>(<i>n</i>).
      </p>
      <h2 className="font-bold my-2">Концепция</h2>
      <p className="mb-2">
        Идея использования heapify для построения кучи состоит в том, чтобы удовлетворить
        свойства структуры и порядка. Нам нужно убедиться, что наша бинарная куча
        представляет собой полное бинарное дерево и что значение каждого узла не превышает
        значения его родителя.
      </p>
      <p className="mb-2">
        Поскольку листовые узлы не могут нарушать свойства min heap, для них нет
        необходимости выполнять <code>heapify()</code>.
      </p>
      <p className="mb-2">
        Поскольку мы пропускаем все листовые узлы, нам нужно начать только с{' '}
        <code>Math.floor(heap.length / 2)</code>. Затем нам нужно спуститься вниз точно
        так же, как мы это делали в предыдущей статье в методе <code>pop()</code>. Мы не
        будем подробно рассматривать код, поскольку большая его часть аналогична методу{' '}
        <code>pop()</code>.
      </p>
      <Code value={HEAPIFY} />
      <p className="mb-2">
        Начиная с первого нелистового узла, мы будем спускаться вниз точно так же, как мы
        это делали в функции <code>pop()</code>. После каждой итерации мы будем уменьшать
        индекс на <code>1</code>, чтобы мы могли выполнить <code>heapify()</code> на
        следующем узле, вплоть до индекса <code>1</code>.
      </p>
      <p className="mb-2">
        На изображении ниже показано, как <code>heapify()</code> выполняется на всех
        узлах, начиная с индекса <code>4</code>. Узлы в синих прямоугольниках являются
        листовыми узлами.
      </p>
      <img
        alt="Преобразование в кучу"
        className="mb-2"
        height="1240"
        src={heapify}
        width="1600"
      />
      <h2 className="font-bold my-2">Сложность по времени</h2>
      <p className="mb-2">
        Учитывая, что в бинарном дереве <i>n</i> узлов, существует примерно <i>n</i> /{' '}
        <code>2</code> листовых узлов. Используя эту информацию, мы можем выяснить, на
        сколько уровней должен спуститься вниз каждый узел, а также объём работы, которую{' '}
        <code>heapify()</code> выполняет на каждом уровне.
      </p>
      <p className="mb-2">
        Мы не выполняем heapify на 3-м/последнем уровне. Узлы на 2-м уровне должны
        спуститься на один уровень ниже, а узлы на 1-м уровне спускаются вниз на два
        уровня, при этом корневой узел должен спуститься вниз по всем уровням. Таким
        образом, хотя количество узлов каждый раз уменьшается вдвое, количество уровней,
        которые необходимо пройти, увеличивается. Когда мы складываем всю работу вместе,
        получается очень аккуратное математическое суммирование, которое упрощается до{' '}
        <i>O</i>(<i>n</i>), но мы не будем его рассматривать. Крайне маловероятно, что вас
        попросят доказать сложность по времени <code>heapify()</code>, поэтому достаточно
        знать, что она равна <i>O</i>(<i>n</i>).
      </p>
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        Задачи с BST распространены, но когда дело доходит до использования структуры
        данных в качестве утилиты, они гораздо чаще встречаются с кучей. Если вам
        постоянно нужно находить максимальное или минимальное значение в задаче, отличным
        вариантом будет использование min heap или max heap.
      </p>
      <p className="mb-2">
        <strong>
          Иногда задача требует найти элементы «Top K» по некоторым критериям. Эти вопросы
          созданы для того, чтобы решать их с помощью кучи.
        </strong>
      </p>
    </>
  );
}

export default Heapify;
