import palindromes1 from 'assets/palindromes1.png?url';
import palindromes2 from 'assets/palindromes2.png?url';
import palindromes3 from 'assets/palindromes3.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const LONGEST_PALINDROMIC_SUBSTRING_FIRST_PART = `function longest(s) {
  let length = 0;

  for (let i = 0; i < s.length; i++) {
    // нечётная длина
    let l = i;
    let r = i;

    while (l >= 0 && r < s.length && s[l] === s[r]) {
      if (r - l + 1 > length) {
        length = r - l + 1;
      }

      l--;
      r++;
    }
  }

  return length;
}`;

const LONGEST_PALINDROMIC_SUBSTRING_FULL = `function longest(s) {
  let length = 0;

  for (let i = 0; i < s.length; i++) {
    // нечётная длина
    let l = i;
    let r = i;

    while (l >= 0 && r < s.length && s[l] === s[r]) {
      if (r - l + 1 > length) {
        length = r - l + 1;
      }

      l--;
      r++;
    }

    // чётная длина
    l = i;
    r = i + 1;

    while (l >= 0 && r < s.length && s[l] === s[r]) {
      if (r - l + 1 > length) {
        length = r - l + 1;
      }
  
      l--;
      r++;
    }
  }

  return length;
}`;

const LONGEST_PALINDROMIC_SUBSTRING_REFACTORED = `function longest2(s) {
  let length = 0;

  for (let i = 0; i < s.length; i++) {
    // нечётная длина
    length = Math.max(length, helper(s, i, i));
    
    // чётная длина
    length = Math.max(length, helper(s, i, i + 1)); 
  }
    
  return length;
}

function helper(s, l, r) {
  let maxLength = 0;

  while (l >= 0 && r < s.length && s[l] === s[r]) {
    if (r - l + 1 > maxLength) {
      maxLength = r - l + 1;
    }

    l--;
    r++;
  }

  return maxLength;
}`;

function Palindromes(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Удивительно, но задачи с палиндромами также можно решить с помощью динамического
        программирования. Хотя шаблон, по которому они решаются, не является типичным
        подходом DFS/мемоизации/динамического программирования снизу. Лучше всего
        продемонстрировать это на примере.
      </p>
      <p className="mb-2">Предположим, перед нами стоит следующий вопрос:</p>
      <p className="mb-2">
        <strong>
          Дана строка S, верните длину самой длинной палиндромной подстроки внутри S.
        </strong>
      </p>
      <p className="mb-2">
        Палиндром — это последовательность символов, которая одинаково читается как в
        прямом, так и в обратном направлении. Например, «racecar» или «aba». Итак, по
        определению палиндромная подстрока — это непрерывная часть строки, которая
        является палиндромом.
      </p>
      <p className="mb-2">
        В статье о методе двух указателей мы обсуждали, как определить, является ли строка
        палиндромом. Однако здесь мы сталкиваемся с вариацией, а именно нахождением длины
        самой длинной палиндромной подстроки.
      </p>
      <h2 className="font-bold my-2">Подход грубой силы</h2>
      <p className="mb-2">
        Самый простой способ решить эту задачу — просмотреть все возможные подстроки и
        определить, являются ли они палиндромами, используя метод двух указателей. Если{' '}
        <i>n</i> — количество символов в нашей строке, а количество подстрок, которые
        может образовывать каждый символ, линейно увеличивается до <i>n</i>, всего у нас
        будет <i>n</i>
        <sup>2</sup> подстрок. Затем, учитывая эти <i>n</i>
        <sup>2</sup> подстрок и самую длинную подстроку длиной <i>n</i>, общая сложность
        по времени достигает <i>O</i>(<i>n</i>
        <sup>3</sup>).
      </p>
      <h2 className="font-bold my-2">Подход динамического программирования</h2>
      <p className="mb-2">
        Если мы сравним первый и последний символ и они равны, подзадача состоит в том,
        чтобы определить, является ли внутренняя строка, за исключением символов по
        индексам <code>0</code> и <code>length - 1</code>, палиндромом. Если внутренняя
        строка является палиндромом, как и самые внешние символы, мы знаем, что вся
        подстрока является палиндромом.
      </p>
      <p className="mb-2">
        Подход к этой проблеме с помощью динамического программирования говорит нам, что
        сначала мы должны решить подзадачу. Учитывая строку{' '}
        <code>s = &apos;abaab&apos;</code>, мы можем начать с середины и расширяться
        наружу. Однако это даст нам только палиндромные подстроки с символом{' '}
        <code>a</code> в середине. Это не гарантирует, что мы получим самую длинную
        палиндромную подстроку, а в случае <code>s</code> этот подход не работает,
        поскольку самая длинная палиндромная подстрока — это <code>baab</code>, которая не
        образуется путем расширения из <code>a</code> по 2-му индексу.
      </p>
      <p className="mb-2">
        <strong>
          На изображении ниже показаны все подстроки, где символ <code>a</code> по индексу
          2 является средним символом.
        </strong>
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Полиндромные подстроки для символа из середины строки"
          className="mx-auto"
          height="360"
          src={palindromes1}
          width="760"
        />
      </figure>
      <p className="mb-2">
        Поскольку не гарантируется, что выбор среднего символа приведет к созданию самой
        длинной палиндромной подстроки, единственный способ — выбрать каждый символ и
        расширить его, используя левый и правый указатель. Для этого мы можем запустить
        цикл <code>for</code> по нашей строке и на каждой итерации устанавливать начальную
        позицию левого и правого указателя на текущий символ. Затем, пока наши левая и
        правая стороны не выходят за пределы, а символ слева соответствует символу справа,
        мы можем уменьшать левый и увеличивать правый указатели (это часть расширения).
        Затем мы можем взять разницу между нашим левым и правым указателем и добавить{' '}
        <code>1</code>, чтобы включить все элементы. Это показано на изображении и в коде
        ниже:
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Полиндромные подстроки для каждого символа в качестве середины подстроки"
          className="mx-auto"
          height="660"
          src={palindromes2}
          width="1200"
        />
      </figure>
      <Code value={LONGEST_PALINDROMIC_SUBSTRING_FIRST_PART} />
      <p className="mb-2">
        Вы заметили небольшую ошибку? Самая длинная палиндромная подстрока имеет длину{' '}
        <code>3</code>, но мы ясно видим, что это должна быть длина <code>baab</code> —{' '}
        <code>4</code>, которую наш алгоритм не смог учесть. Вы также могли заметить, что
        все приведённые выше палиндромы имеют нечётную длину. Это потому, что наша
        начальная подстрока имеет длину <code>1</code>, и когда мы расширяем слева и
        справа, мы добавляем <code>2</code> к нашей длине. Конечно, сумма чётного и
        нечётного числа всегда нечётна, в результате чего мы получаем самую длинную
        палиндромную подстроку нечётной длины.
      </p>
      <h2 className="font-bold my-2">Подстроки чётной длины</h2>
      <p className="mb-2">
        Чтобы гарантировать, что мы получим самую длинную палиндромную подстроку, чётную
        или нечётную, нам нужно начать с начальной подстроки чётной длины. Таким образом,
        мы учтём и подстроки чётной длины. Чтобы вычислить самую длинную палиндромную
        подстроку, мы можем вернуть <code>Math.max(нечётная, чётная)</code>. На
        изображении ниже мы начинаем с <code>ab</code> и пытаемся расшириться наружу.
        Поскольку <code>ab</code> не является палиндромом, мы никогда не войдём в цикл{' '}
        <code>while</code>. Когда мы доберёмся до <code>aa</code>, расширение наружу даст
        нам <code>baab</code>, прежде чем наш правый указатель выйдет за пределы. Это
        самая длинная палиндромная подстрока с длиной <code>4</code>.
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Полиндромные подстроки для каждой пары символов в качестве середины подстроки"
          className="mx-auto"
          height="560"
          src={palindromes3}
          width="1200"
        />
      </figure>
      <p className="mb-2">Наш окончательный код будет выглядеть следующим образом:</p>
      <Code value={LONGEST_PALINDROMIC_SUBSTRING_FULL} />
      <p className="mb-2">
        Или переработанная версия со вспомогательной функцией, обеспечивающая более чистый
        код:
      </p>
      <Code value={LONGEST_PALINDROMIC_SUBSTRING_REFACTORED} />
      <h2 className="font-bold my-2">Сложность по времени и памяти</h2>
      <p className="mb-2">
        Решение динамического программирования доводит нашу сложность по времени <i>O</i>(
        <i>n</i>
        <sup>3</sup>) до <i>O</i>(<i>n</i>
        <sup>2</sup>), поскольку у нас есть <i>n</i> символов, и формирование подстроки
        для каждого символа также требует <i>n</i>.
      </p>
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        Переработанная версия кода была добавлена для полноты, поскольку она позволяет
        избежать написания дублирующегося кода.
      </p>
    </>
  );
}

export default Palindromes;
