import trie from 'assets/trie.png?url';
import trieInsertApple from 'assets/trie-insert-apple.png?url';
import trieInsertApe from 'assets/trie-insert-ape.png?url';
import trieInsertNope from 'assets/trie-insert-nope.png?url';
import trieSearch from 'assets/trie-search.png?url';
import trieStartsWith from 'assets/trie-starts-with.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const TRIE_NODE = `class TrieNode {
  constructor() {
    this.word = false;
    this.children = new Map();
  }
}`;

const TRIE = `class Trie {
  constructor() {
    this.root = new TrieNode(); 
  }
  
  ...
}`;

const INSERT = `insert(word) {
  let curr = this.root;

  for (const char of word) {
    if (!curr.children.has(char)) {
      curr.children.set(char, new TrieNode());
    }

    curr = curr.children.get(char);
  }

  curr.word = true;
}`;

const SEARCH = `search(word) {
  let curr = this.root;

  for (const char of word) {
    if (!curr.children.has(char)) {
      return false;
    }

    curr = curr.children.get(char);
  }

  return curr.word;
}`;

const STARTS_WITH = `startsWith(prefix) {
  let curr = this.root;

  for (let char of prefix) {
    if (!curr.children.has(char)) {
      return false;
    }

    curr = curr.children.get(char);
  }

  return true;
}`;

function Trie(): ReactElement {
  return (
    <>
      <h2 className="font-bold my-2">Мотивация</h2>
      <p className="mb-2">Давайте объясним, почему нам нужно префиксное дерево (trie).</p>
      <p className="mb-2">
        Представьте, что у нас есть большая коробка, наполненная разными овощами, такими
        как кабачки, капуста, помидоры и т. д. Если бы мы хотели упорядочить их по именам,
        нам нужно было бы начать с коробок меньшего размера и пометить каждую из них
        каждой буквой алфавита. Таким образом, все овощи, названия которых начинаются с
        буквы «А», попадут в коробку с надписью «А» и т. д. и т. п.
      </p>
      <p className="mb-2">
        Но есть овощи, у которых общая первая буква или даже несколько первых букв,
        например «кабачок» и «капуста». Вместо того, чтобы создавать новые коробки для
        каждого префикса, мы можем создавать новые коробки внутри исходной коробки, чтобы
        каждая новая коробка использовалась для обозначения каждой дополнительной буквы в
        названии нашего овоща.
      </p>
      <p className="mb-2">
        Итак, теперь, когда у нас есть дополнительные коробки внутри, скажем, коробки «к»,
        помеченные второй буквой названия каждого овоща, мы можем положить «кабачок» и
        «капусту» в одну и ту же коробку и т. д. и т. п. Мы можем продолжать делать это
        для каждой буквы алфавита, пока у нас не появится группа меньших коробок внутри
        больших коробок.
      </p>
      <p className="mb-2">
        Префиксное дерево позволяет нам организовывать слова по первым нескольким буквам
        (префиксам). В случае дерева каждая коробка для овощей будет представлена как
        узел, а рёбра будут использоваться для обозначения букв, которые их соединяют.
      </p>
      <p className="mb-2">
        Префиксное дерево представляет собой древовидную структуру данных, которую можно
        использовать для поиска слов по заданному префиксу. Оно позволяет делать это за{' '}
        <i>O</i>(1) по времени.
      </p>
      <p className="mb-2">
        Мы хотим иметь возможность вставки и поиска таким образом, чтобы у нас получились
        следующие сложности:
      </p>
      <ul className="mb-2">
        <li>
          Вставка слова: <i>O</i>(1)
        </li>
        <li>
          Поиск слова: <i>O</i>(1)
        </li>
        <li>
          Поиск префикса: <i>O</i>(1)
        </li>
      </ul>
      <p className="mb-2">
        <strong>
          Вы можете подумать про себя, что нельзя ли выполнить описанные выше операции и с
          объектом? Да, но объект будет поддерживать только точное совпадение строки,
          поэтому в худшем случае поиск префикса займёт <i>O</i>(<i>n</i>) итераций.
          Префиксное дерево позволит нам искать строки, начинающиеся с определённого
          префикса, за <i>O</i>(1) по времени.
        </strong>
      </p>
      <p className="mb-2">
        Возможно, вы уже поняли, что реальным применением префиксного дерева является
        автозаполнение поисковой системы. Автозаполнение сопоставляет буквы префикса,
        чтобы предсказать слова, которые вы собираетесь ввести. А поскольку поиск префикса
        составляет <i>O</i>(1), он выполняется быстро и эффективно.
      </p>
      <p className="mb-2">
        На изображении ниже показано префиксное дерево. Для примеров возьмём английский
        алфавит. Поскольку в алфавите 26 букв, каждый узел будет иметь не более 26
        дочерних элементов. Для краткости мы использовали <strong>...</strong> для
        обозначения всех букв между c и z.
      </p>
      <img alt="Префиксное дерево" className="mb-2" height="300" src={trie} width="500" />
      <h2 className="font-bold my-2">Реализация</h2>
      <ul>
        <li>
          <p className="mb-2">
            <strong>Узел префиксного дерева</strong>
          </p>
          <p className="mb-2">
            Когда мы вставляем в дерево, мы вставляем слова, даже если они представляют
            собой отдельные символы. Нам нужно сделать это, чтобы при поиске мы могли
            определить, существует слово или нет. Итак, каждый узел, назовем его{' '}
            <code>TrieNode</code>, должен отслеживать свои дочерние узлы и иметь
            логическую переменную, которая определяет, заканчивается ли слово на этом{' '}
            <code>TrieNode</code>. Для этого мы можем создать отдельный класс{' '}
            <code>TrieNode</code>.
          </p>
          <Code value={TRIE_NODE} />
          <p className="mb-2">
            Итак, теперь всякий раз, когда мы добавляем экземпляр класса <code>Trie</code>
            , у нас будет новый <code>TrieNode</code> в качестве корневого узла в
            конструкторе.
          </p>
        </li>
        <li>
          <p className="mb-2">
            <strong>Класс префиксного дерева</strong>
          </p>
          <Code value={TRIE} />
          <ul>
            <li className="mb-2">
              <p className="mb-2">
                <strong>Вставка слова</strong>
              </p>
              <p className="mb-2">
                Чтобы вставить в префиксное дерево, мы можем перебрать каждый символ
                слова, которое хотим вставить. Если символ не существует, мы можем
                вставить его в наш <code>Map</code> вместе с его дочерними элементами. В
                противном случае мы можем продолжить движение вниз по дереву. Достигнув
                последнего символа, мы можем пометить этот <code>TrieNode</code> как
                слово.
              </p>
              <p className="mb-2">
                Поскольку мы используем <code>Map</code> для хранения дочерних элементов,
                мы можем получить дочерние элементы за <i>O</i>(1) по времени.
              </p>
              <Code value={INSERT} />
              <p className="mb-2">
                <strong>
                  На изображениях ниже показан процесс вставки слов «apple», «ape» и
                  «nope». <code>curr</code> представляет текущий <code>TrieNode</code> (в
                  красных кружках), а логическое значение <code>word</code> показывает,
                  заканчивается ли слово на <code>TrieNode</code>.
                </strong>
              </p>
              <figure className="bg-white mb-2">
                <img
                  alt="Вставка слова 'apple' в префиксное дерево"
                  className="mx-auto mt-2"
                  height="1100"
                  src={trieInsertApple}
                  width="800"
                />
              </figure>
              <figure className="bg-white mb-2">
                <img
                  alt="Вставка слова 'ape' в префиксное дерево"
                  className="mx-auto"
                  height="630"
                  src={trieInsertApe}
                  width="1300"
                />
              </figure>
              <img
                alt="Вставка слова 'nope' в префиксное дерево"
                className="mb-2"
                height="1200"
                src={trieInsertNope}
                width="1761"
              />
            </li>
            <li className="mb-2">
              <p className="mb-2">
                <strong>Поиск слова</strong>
              </p>
              <p className="mb-2">
                Мы можем проверить, существует ли слово, и вернуть логическое значение.
                Для этого мы пройдёмся по каждому символу и как только встретим символ,
                которого нет в нашем дереве, мы сможем вернуть <code>false</code>. Это
                имеет смысл, поскольку слово не может быть полным, если один из символов
                отсутствует. Однако может быть и так, что существует каждый отдельный
                символ, но последний символ не помечен как слово. Например, если в нашем
                префиксном дереве есть слово «apple», а мы ищем слово «app», даже если
                префикс существует, само слово не существует, поскольку атрибут{' '}
                <code>word</code> <code>&apos;p&apos;</code> равен <code>false</code>.
              </p>
              <Code value={SEARCH} />
              <p className="mb-2">
                <strong>На изображении ниже показан поиск по слову «no».</strong>
              </p>
              <img
                alt="Поиск слова в префиксном дереве"
                className="mb-2"
                height="640"
                src={trieSearch}
                width="1660"
              />
            </li>
            <li className="mb-2">
              <p className="mb-2">
                <strong>Поиск префикса</strong>
              </p>
              <p className="mb-2">
                Если мы хотим узнать, содержит ли наше дерево слово с префиксом, мы можем
                использовать следующий метод. Если каждый символ префикса существует в
                нашем префиксном дереве, мы можем вернуть <code>true</code>. В противном
                случае мы вернем <code>false</code>.
              </p>
              <Code value={STARTS_WITH} />
              <p className="mb-2">
                <strong>Префикс «no» существует в нашем дереве.</strong>
              </p>
              <img
                alt="Поиск префикса в префиксном дереве"
                className="mb-2"
                height="651"
                src={trieStartsWith}
                width="1661"
              />
            </li>
          </ul>
        </li>
      </ul>
      <h2 className="font-bold my-2">Сложность по времени и памяти</h2>
      <p className="mb-2">
        Если бы у нас не было префиксного дерева, выполнение поиска методом грубой силы
        представляло бы собой перебор всех слов и проверку, какие из них совпадают. Это
        даёт нам сложность по времени <i>O</i>(<i>n</i> ∗ <i>m</i>), где <i>n</i> —
        количество слов, а <i>m</i> — средняя длина каждого слова.
      </p>
      <p className="mb-2">
        Префиксные деревья позволяют нам сделать это за время <i>O</i>(<i>m</i>). Это
        связано с тем, что мы итерируемся один раз для каждого символа в целевом слове.
      </p>
    </>
  );
}

export default Trie;
