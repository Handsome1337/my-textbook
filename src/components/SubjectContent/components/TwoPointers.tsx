import twoPointers from 'assets/two-pointers.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const IS_PALINDROME = `function isPalindrome(word) {
  let l = 0;
  let r = word.length - 1;

  while (l < r) {
    if (word[l] !== word[r]) {
      return false;
    }

    l++;
    r--;
  }

  return true;
}`;

const TARGET_SUM = `function targetSum(nums, target) {
  let l = 0;
  let r = nums.length - 1;

  while (l < r) {
    if (nums[l] + nums[r] > target) {
      r--;
    } else if (nums[l] + nums[r] < target) {
      l++;
    } else {
      return [l, r];
    }
  }
}`;

function TwoPointers(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Метод двух указателей — это популярный шаблон решения задач, особенно полезный при
        работе с массивами и строками. Основная идея состоит в том, чтобы иметь указатель{' '}
        <code>L</code> (левый) и указатель <code>R</code> (правый), которые начинаются с
        некоторого индекса массива или строки. Куда они изначально указывают, зависит от
        решаемой проблемы.
      </p>
      <h2 className="font-bold my-2">Концепция</h2>
      <p className="mb-2">
        Установим указатели на начало и конец массива (или строки): указатель{' '}
        <code>L</code> на <code>0</code> и указатель <code>R</code> на{' '}
        <code>length - 1</code>. Будем увеличивать <code>L</code>, либо уменьшать{' '}
        <code>R</code>, либо делать и то и другое, в зависимости от условий, заданных в
        задаче. Будем повторять это до тех пор, пока указатели не встретятся друг с
        другом.
      </p>
      <h2 className="font-bold my-2">Примеры</h2>
      <ul>
        <li>
          <strong>Проверьте, является ли строка палиндромом.</strong>
          <p className="mb-2">
            Палиндром — это последовательность (строка, массив и т. п.), которая одинаково
            читается слева направо и справа налево. Мы можем использовать нашу реализацию
            с методом двух указателей, о которой упомянуто выше. Если у нас есть строка{' '}
            <code>word</code> и наш левый указатель начинается с индекса <code>0</code>, а
            правый указатель с индекса <code>word.length - 1</code>, каждый символ в
            каждом <code>L</code> должен совпадать с каждым символом в <code>R</code>.
          </p>
          <Code value={IS_PALINDROME} />
        </li>
        <li>
          <strong>
            Дан отсортированный массив и значение <code>target</code>. Верните индексы
            двух элементов, которые в сумме дают переданное <code>target</code>.
            Предполагается, что существует ровно одно решение.
          </strong>
          <p className="mb-2">
            Тривиальным подходом был бы перебор каждой пары чисел, однако такой перебор
            составил бы <i>O</i>(<i>n</i>
            <sup>2</sup>) по времени, мы можем сделать лучше.
          </p>
          <p className="mb-2">
            Поскольку массив отсортирован, мы можем использовать эту информацию для
            разумного перемещения указателей. Как и в предыдущем примере, установим наши
            указатели <code>L</code> и <code>R</code> на <code>0</code> и{' '}
            <code>arr.length - 1</code> соответственно. Вычислим сумму элементов, на
            которые указывают указатели. Если сумма слишком большая, мы можем передвинуть
            указатель <code>R</code> влево (уменьшить на 1), а если сумма слишком
            маленькая, то мы можем передвинуть указатель <code>L</code> вправо.
          </p>
          <strong>
            Причина, по которой мы можем уменьшить <code>R</code>, чтобы сделать сумму
            меньше, заключается в том, что каждое число слева от <code>arr[R]</code>{' '}
            меньше чем <code>arr[R]</code>. Аналогично каждое число справа от{' '}
            <code>arr[L]</code> больше, чем <code>arr[L]</code>.
          </strong>
          <Code value={TARGET_SUM} />
        </li>
      </ul>
      <img alt="Метод двух указателей" height="400" src={twoPointers} width="1700" />
      <h2 className="font-bold my-2">Сложность по времени</h2>
      <p className="mb-2">
        Сила этого метода в том, что он позволяет нам иметь максимум <i>n</i> итераций,
        что избавляет нас от тонны избыточной работы, которую мы могли бы выполнить,
        используя метод грубой силы (полного перебора).
      </p>
    </>
  );
}

export default TwoPointers;
