import fibonacci1 from 'assets/fibonacci1.png?url';
import fibonacci2 from 'assets/fibonacci2.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const FIBONACCI = `function fibonacci(n) {
  // Базовый случай: n = 0 или 1
  if (n <= 1) {
    return n;
  }

  // Рекурсивный случай: fib(n) = fib(n - 1) + fib(n - 2)
  return fibonacci(n - 1) + fibonacci(n - 2);
}`;

function TwoBranchRecursion(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Более интересный вид рекурсии — это рекурсия с двумя ветвями. Опять же, давайте
        возьмём математический пример, чтобы рассмотреть это - последовательность
        Фибоначчи. Математическая формула для расчёта <i>n</i> числа Фибоначчи состоит в
        том, чтобы взять числа{' '}
        <code>
          <i>n</i> - 1
        </code>{' '}
        и{' '}
        <code>
          <i>n</i> - 2
        </code>{' '}
        и сложить их. Известно, что{' '}
        <code>
          <i>F</i>(0) = 0
        </code>{' '}
        и{' '}
        <code>
          <i>F</i>(1) = 1
        </code>
        , что в рекурсивной функции будет нашим базовым случаем.
      </p>
      <p className="mb-2">Формула будет записана так:</p>
      <p className="mb-2">
        <code>
          <i>fib</i>(<i>n</i>) = <i>fib</i>(<i>n</i> - 1) + <i>fib</i>(<i>n</i> - 2)
        </code>
      </p>
      <p className="mb-2">
        <strong>Вышеуказанное известно как рекуррентное соотношение.</strong>
      </p>
      <h2 className="font-bold my-2">Концепция</h2>
      <p className="mb-2">
        Мы можем визуализировать математическую формулу с помощью следующего дерева.
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Последовательность Фибоначчи в виде дерева"
          className="mx-auto"
          height="580"
          src={fibonacci1}
          width="1180"
        />
      </figure>
      <Code value={FIBONACCI} />
      <p className="mb-2">
        Приведённый выше псевдокод аналогичен нашему предыдущему примеру с факториалом, за
        исключением того, что здесь коэффициент ветвления равен двум. Обратите внимание,
        как мы дважды вызываем функцию в последней строке, в результате чего получается
        дерево, показанное на изображении.
      </p>
      <p className="mb-2">
        Для анализа давайте воспользуемся той же техникой, которую мы представили в
        предыдущей статье. У нас есть базовый случай, мы знаем, что функция вызывает себя
        в последнем операторе <code>return</code>, и мы знаем, что в какой-то момент,
        когда базовый случай будет достигнут, нам придется вернуться «вверх», чтобы
        вычислить окончательный ответ. Чтобы вычислить <code>fibonacci(5)</code>, мы
        получаем <code>fibonacci(4) + fibonacci(3)</code>. Теперь оба этих вызова
        выполняют функцию заново. Глядя на наше дерево, <code>fibonacci(4)</code> вызовет{' '}
        <code>fibonacci(3) + fibonacci(2)</code> и так далее, пока <i>n</i> не достигнет{' '}
        <code>1</code> или <code>0</code>, после чего функция вернёт результат и продолжит
        идти вверх до тех пор, пока <code>fibonacci(4)</code> не даст нам ответ{' '}
        <code>3</code>. Теперь у нас есть ответ для <code>fibonacci(4)</code>, и мы делаем
        то же самое для <code>fibonacci(3)</code>, получая <code>2</code>. Сложим эти два
        числа, и получим 5-ое число Фибоначчи, которое будет равно <code>5</code>.
      </p>
      <h2 className="font-bold my-2">Оценка сложности по времени</h2>
      <p className="mb-2">
        Оценить сложность по времени для этого случая немного сложнее. Давайте
        проанализируем дерево и количество узлов на каждом из уровней. На 1-ом уровне (0
        индекс) находится <code>1</code> узел, на 2-ом — <code>2</code>, затем{' '}
        <code>4</code>, после чего мы видим закономерность. Каждый уровень может содержать
        в два 2 раза больше узлов, чем предыдущий уровень.
      </p>
      <p className="mb-2">
        Это даёт нам только половину ответа. Если <i>n</i> — уровень, на котором мы сейчас
        находится, это означает, что для получения количества узлов на любом уровне{' '}
        <i>n</i> используется формула{' '}
        <code>
          2
          <sup>
            <i>n</i>
          </sup>
        </code>
        . Поскольку нам потенциально необходимо пройти весь путь до <i>n</i>-го уровня, а
        на каждом уровне в два раза больше узлов, мы можем сказать, что сложность по
        времени составляет <i>O</i>(2
        <sup>
          <i>n</i>
        </sup>
        ) .
      </p>
      <p className="mb-2">
        Алгоритмически говоря, даже если бы у нас было 2 * 2
        <sup>
          <i>n</i>
        </sup>{' '}
        или 2
        <sup>
          <i>n</i>
        </sup>{' '}
        - 1 операций, сложность бы всё равно составляла <i>O</i>(2
        <sup>
          <i>n</i>
        </sup>
        ), поскольку константы не влияют на сложность.
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Последовательность Фибоначчи в виде дерева"
          className="mx-auto"
          height="640"
          src={fibonacci2}
          width="1420"
        />
      </figure>
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        В следующих статьях мы будем возвращаться к рекурсии снова и снова, и она
        действительно хороша, когда дело доходит до обхода деревьев и графов.
      </p>
    </>
  );
}

export default TwoBranchRecursion;
