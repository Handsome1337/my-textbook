import unionFind1 from 'assets/union-find1.png?url';
import unionFind2 from 'assets/union-find2.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const UNION_FIND_SETUP = `class UnionFind {
  parent = new Map();
  rank = new Map();

  constructor(n) {
    for (let i = 1; i < n + 1; i++) {
      this.parent.set(i, i);
      this.rank.set(i, 0);
    }
  }
}`;

const FIND = `find(n) {
  let parent = this.parent.get(n);

  while (parent != this.parent.get(parent)) {
    this.parent.set(parent, this.parent.get(this.parent.get(parent)));
    parent = this.parent.get(parent);
  }

  return parent;
}`;

const UNION = `union(n1, n2) {
  const p1 = this.find(n1);
  const p2 = this.find(n2);

  if (p1 === p2) {
    return false;
  }

  if (this.rank.get(p1) > this.rank.get(p2)) {
    this.parent.set(p2, p1);
  } else if (this.rank.get(p1) < this.rank.get(p2)) {
    this.parent.set(p1, p2);
  } else {
    this.parent.set(p1, p2);
    this.rank.set(p2, this.rank.get(p2) + 1);
  }

  return true;
}`;

function UnionFind(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Система непересекающихся множеств (Union-Find) — полезный инструмент для
        отслеживания узлов, соединённых в графе, и обнаружения циклов в графе. Конечно, мы
        можем добиться этого и с помощью DFS, используя <code>Set</code>, скажем,{' '}
        <code>seen</code>. Однако DFS является хорошим выбором, когда имеется статический
        граф, т. е. со временем рёбра не добавляются. Если мы со временем добавляем рёбра,
        это делает граф динамичным, и Union-Find — лучший выбор. Хотя она используется
        реже, чем DFS.
      </p>
      <h2 className="font-bold my-2">Непересекающиеся множества</h2>
      <p className="mb-2">
        Union-Find работает с непересекающимися множествами. Давайте кратко пробежимся по
        ним.
      </p>
      <p className="mb-2">
        Непересекающиеся множества — это множества, которые не имеют общих элементов.
        Формально два непересекающихся множества — это множества, пересечением которых
        является пустое множество. Предположим, у нас есть два множества:{' '}
        <code>S1 = &#123;1, 2, 3&#125;</code> и <code>S2 = &#123;4, 5, 6&#125;</code>.{' '}
        <code>S1</code> и <code>S2</code> называются непересекающимися множествами, а два
        множества <code>S3 = &#123;1, 2, 5&#125;</code> и{' '}
        <code>S4 = &#123;5, 6, 7&#125;</code> не являются непересекающимися.
      </p>
      <p className="mb-2">
        Union-Find работает с непересекающимися множествами. Если мы хотим выполнить
        объединение двух вершин, нам нужно убедиться, что эти вершины принадлежат
        непересекающимся множествам.
      </p>
      <h2 className="font-bold my-2">Концепция</h2>
      <p className="mb-2">
        Предположим, нам дан массив рёбер, <code>edges = [[1, 2], [4, 1], [2, 4]]</code>,
        и нас просят построить граф и обнаружить цикл. Здесь каждый массив рёбер
        представляет собой ненаправленную связную пару вершин, т. е. <code>1</code>{' '}
        соединена с <code>2</code>, и т. д.
      </p>
      <p className="mb-2">
        Union-Find называют «лесом деревьев». Изначально каждая вершина существует сама по
        себе, и для каждой вершины мы хотим сохранить указатель на её родителя. Поскольку
        мы их ещё не соединили, каждый узел является родителем самого себя, т.е. указывает
        на себя.
      </p>
      <img alt="Вершины" className="mb-2" height="170" src={unionFind1} width="481" />
      <p className="mb-2">
        Затем мы хотим соединить компоненты вместе. Поскольку <code>2</code> соединена с{' '}
        <code>1</code>, мы можем сделать её дочерней для <code>1</code>. Здесь не имеет
        значения, какая вершина является родительской, а какая дочерней. Однако этот
        порядок начинает иметь значение, когда два компонента, которые мы пытаемся
        объединить, имеют разную высоту, также называемую рангом. Если вы не уверены в
        этой части, не волнуйтесь, мы скоро продолжим эту тему.
      </p>
      <p className="mb-2">
        Структура данных Union-Find имеет две операции. Операция поиска и операция
        объединения. Мы хотим быть уверены, что не соединяем вершины, являющиеся частью
        одного и того же компонента. Итак, по заданной вершине <code>n</code> операция
        поиска находит родителя <code>n</code>. Затем мы можем использовать это в операции
        объединения, чтобы соединить вершины вместе.
      </p>
      <h2 className="font-bold my-2">Реализация</h2>
      <p className="mb-2">
        Для реализации Union-Find у нас может быть класс <code>UnionFind</code>, с помощью
        которого мы можем создать экземпляр нашего <code>Map</code> <code>parent</code> и
        нашего <code>Map</code> <code>rank</code>. Некоторым людям нравится использовать
        массивы вместо <code>Map</code>, и это тоже допустимый вариант.
      </p>
      <h2 className="font-bold my-2">Начальная настройка</h2>
      <Code value={UNION_FIND_SETUP} />
      <h2 className="font-bold my-2">Поиск</h2>
      <p className="mb-2">
        Наша функция поиска примет вершину <code>n</code> в качестве аргумента и вернет её
        родителя. Мы можем сделать это, используя наш <code>Map</code> <code>parent</code>
        , где ключом является вершина, а значением — родительский узел. Если вершина
        является родителем самой себе, мы можем просто вернуть саму вершину.
      </p>
      <h2 className="font-bold my-2">Сжатие пути</h2>
      <p className="mb-2">
        Поскольку мы выполняем объединение большого количества вершин, в конечном итоге
        может возникнуть довольно длинная цепочка, похожая на длинный связный список.
        Затем, чтобы определить, являются ли два узла частью одного и того же компонента,
        нам потребуется много шагов. Однако мы можем уменьшить количество этих шагов,
        проходя две вершины за раз вместо одной. Это означало бы, что когда мы поднимаемся
        по дереву, родитель на самом деле является родителем родителя. В первый раз это не
        приведёт к улучшению производительности, но если мы когда-нибудь снова встретим ту
        же вершину, мы сможем немедленно получить родительскую вершину. Это называется
        сжатием пути.
      </p>
      <Code value={FIND} />
      <p className="mb-2">
        Строка{' '}
        <code>this.parent.set(parent, this.parent.get(this.parent.get(parent)));</code>{' '}
        выполняет сжатие пути. Она обновляет родителя данной вершины, чтобы он указывал на
        родителя родителя.
      </p>
      <h2 className="font-bold my-2">Объединение</h2>
      <p className="mb-2">
        Функция объединения принимает две вершины и определяет, можно ли выполнить
        объединение. Если две вершины имеют одного и того же родителя, объединение не
        может быть сформировано, и мы можем вернуть <code>false</code>. Если две вершины,
        назовем их <code>n1</code> и <code>n2</code>, имеют родителей <code>p1</code> и{' '}
        <code>p2</code> соответственно, и ранг <code>p1</code> выше, чем <code>p2</code>,
        то <code>p2</code> является дочерним узлом <code>p1</code>. И наоборот,{' '}
        <code>p1</code> является дочерним по отношению к <code>p2</code>, если ранг{' '}
        <code>p2</code> выше, чем <code>p1</code>. Если ранг/высота <code>p1</code> и{' '}
        <code>p2</code> равны, мы можем сделать <code>p2</code> родительским для{' '}
        <code>p1</code> и увеличить ранг на <code>1</code>.
      </p>
      <Code value={UNION} />
      <p className="mb-2">
        На изображении ниже показаны поиск и функция объединения с заданными рёбрами{' '}
        <code>edges = [1, 2], [4, 1], [2, 4]</code>. Обратите внимание, что мы соединяем{' '}
        <code>2</code> с <code>1</code>, затем соединяем <code>4</code> с <code>1</code>,
        потому что <code>1</code> имеет более высокий ранг. Но когда мы достигаем{' '}
        <code>[2, 4]</code>, родительский узел <code>2</code> - это <code>1</code>, а
        родительский узел <code>4</code> - также <code>1</code>, что означает, что они
        принадлежат одному и тому же связному компоненту, т. е. существует цикл.
      </p>
      <figure className="bg-white mb-2">
        <img
          alt="Система непересекающихся множеств"
          className="mx-auto"
          height="380"
          src={unionFind2}
          width="1060"
        />
      </figure>
      <h2 className="font-bold my-2">Сложность по времени и памяти</h2>
      <p className="mb-2">
        В наивном случае функция <code>find</code> будет работать за <i>O</i>(<i>n</i>),
        потому что возможно, что дерево представляет собой просто цепочку, подобную
        связному списку, и нам придётся пройти через каждый отдельный узел. При сжатии
        пути, поскольку мы каждый раз обновляем родительский узел до уровня родителя
        родителя, мы можем снизить сложность до <i>O</i>(<i>log n</i>).
      </p>
      <p className="mb-2">
        Если мы совместим это с функцией объединения, мы получим сложность по времени,
        называемую обратной функцией Аккермана, <i>α</i>(<i>n</i>), которую можно
        упростить до постоянного времени, <i>O</i>(1). Итак, если <i>m</i> — количество
        имеющихся у нас рёбер, то сложность Union-Find по времени равна O(<i>m</i> ∗{' '}
        <i>log n</i>).
      </p>
      <p>
        <strong>
          Обратная функция Аккермана в данном случае не очень уместна, но она добавлена
          для полноты картины.
        </strong>
      </p>
    </>
  );
}

export default UnionFind;
