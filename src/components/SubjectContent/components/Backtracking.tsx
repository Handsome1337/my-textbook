import backtracking1 from 'assets/backtracking1.png?url';
import backtracking2 from 'assets/backtracking2.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const CAN_REACH_LEAF = `class TreeNode {
  left = null;
  right = null;

  constructor(val) {
    this.val = val;
  }
}

function canReachLeaf(root) {
  if (!root || root.val === 0) {
    return false;
  }

  if (!root.left && !root.right) {
    return true;
  }

  if (canReachLeaf(root.left)) {
    return true;
  }

  if (canReachLeaf(root.right)) {
    return true;
  }

  return false;
}`;

const LEAF_PATH = `function leafPath(root, path) {
  if (!root || root.val === 0) {
    return false;
  }

  path.push(root.val);
  
  if (!root.left && !root.right) {
    return true;
  }

  if (leafPath(root.left, path)) {
    return true;
  }

  if (leafPath(root.right, path)) {
    return true;
  }

  path.pop();

  return false;
}`;

function Backtracking(): ReactElement {
  return (
    <>
      <h2 className="font-bold my-2">Бэктрекинг</h2>
      <p className="mb-2">
        Поиск с возвратом (бэктрекинг) — это алгоритм, который похож на алгоритм DFS для
        бинарных деревьев, который мы уже обсуждали. Он действует методом грубой силы. Мы
        исследуем возможный способ решения задачи, и если решить задачу этим способом нам
        не удаётся, мы возвращаемся назад и исследуем другие способы, пока не найдём
        решение.
      </p>
      <h2 className="font-bold my-2">Мотивация с примером</h2>
      <p className="mb-2">
        Кратко обсудив, что такое бэктрекинг, и приняв во внимание всё, что мы знаем о
        DFS, давайте посмотрим, как мы будем решать следующую задачу.
      </p>
      <p className="mb-2">
        <strong>
          Определите, существует ли путь от корня дерева до листового узла. Путь не может
          содержать нулей.
        </strong>
      </p>
      <p className="mb-2">
        По сути, проблема заключается в том, можем ли мы пройти от корневого узла к
        листовому узлу, не встречая значения <code>0</code>. Мы возвращаем{' '}
        <code>true</code>, если путь существует, и <code>false</code>, если его нет.
      </p>
      <p className="mb-2">
        Первое, что приходит на ум, — это использование поиска в глубину. Наше ограничение
        состоит в том, что на нашем пути не может быть узла со значением <code>0</code>.
        Мы также знаем, что если дерево пусто, то не может существовать и валидного пути.
        Наконец, если мы достигли листового узла и не вернули <code>false</code>, мы можем
        вернуть <code>true</code>, поскольку это означает, что существует путь от корня до
        листа.
      </p>
      <p className="mb-2">
        Для решения этой проблемы предположим, что существует ровно один путь, поэтому он
        должен существовать либо в правом поддереве, либо в левом поддереве. Произвольно
        мы решаем попробовать левую сторону перед правой. Если ответ не найден в левом
        поддереве, алгоритм будет искать в правом поддереве и, если путь существует,
        вернёт <code>true</code>.
      </p>
      <p className="mb-2">
        Дано дерево <code>[4, 0, 1, null, 7, 2, 0]</code>, валидный путь будет выглядеть
        следующим образом, как показано на изображении. Путь недействителен, если в нем
        есть <code>0</code>.
      </p>
      <p className="mb-2">
        Теперь, когда мы знаем наши базовые случаи, перевести это в код очень просто.
      </p>
      <Code value={CAN_REACH_LEAF} />
      <figure className="bg-white mb-2">
        <img
          alt="Поиск пути от корня до листового узла"
          className="mx-auto"
          height="600"
          src={backtracking1}
          width="1080"
        />
      </figure>
      <p className="mb-2">
        Давайте взглянем на немного изменённую задачу, в которой нам нужно возвращать
        значения пути вместо простого возврата логического значения.
      </p>
      <p className="mb-2">
        В этой задаче мы можем передать параметр <code>path</code>, который представляет
        собой список для хранения всех узлов, находящихся на валидном пути. Итак, учитывая
        дерево <code>[4, 0, 1, null, 7, 3, 2, null, null, null, 0]</code>, мы сначала
        добавляем корневой узел в наш список.
      </p>
      <p className="mb-2">
        Поскольку существует только один валидный путь, он будет находиться либо в левом
        поддереве, либо в правом поддереве. Приоритет левого над правым делает левое
        поддерево недопустимым, поскольку левый дочерний узел <code>4</code> равен{' '}
        <code>0</code>. Мы возвращаем <code>false</code> и теперь рекурсивно проверяем
        правое поддерево. Двигаясь вправо, <code>1</code> является валидным, поэтому мы
        добавляем его в наш список. Теперь мы проверяем <code>3</code>, которое является
        валидным, поэтому оно добавляется в наш список. Левый дочерний узел <code>3</code>{' '}
        равен <code>null</code>, поэтому мы возвращаем <code>false</code>. Проверяя правый
        дочерний узел <code>3</code>, мы снова попадаем в базовый случай. Теперь мы должны
        удалить <code>3</code> из нашего списка, потому что, если бы существовал валидный
        путь, мы бы уже вернули <code>true</code>. Мы возвращаемся к родительскому узлу{' '}
        <code>3</code>, то есть <code>1</code>, и проверяем его правое поддерево.
        Добавляем <code>2</code> в наш список. Затем мы исследуем <code>2</code>, но{' '}
        <code>2</code> — это листовой узел, что заставляет рекурсивный вызов возвратить{' '}
        <code>true</code>, после чего функция возвращает <code>true</code>. Наш валидный
        путь — <code>[4, 1, 2]</code>.
      </p>
      <p className="mb-2">На изображении ниже показан этот процесс.</p>
      <img
        alt="Поиск пути от корня до листового узла"
        className="mb-2"
        height="919"
        src={backtracking2}
        width="1540"
      />
      <Code value={LEAF_PATH} />
      <h2 className="font-bold my-2">Сложность по времени</h2>
      <p className="mb-2">
        Учитывая, что дерево имеет <i>n</i> узлов, сложность по времени будет равна{' '}
        <i>O</i>(<i>n</i>), поскольку нам придётся обойти всё дерево. Как и в любом
        алгоритме грубой силы, нам придётся пройти через входные данные, размер которых в
        данном случае соответствует размеру дерева.
      </p>
      <h2 className="font-bold my-2">Итоги</h2>
      <p className="mb-2">
        Бэктрекинг — это абстрактный алгоритм, и бинарные деревья — не единственная
        структура данных, к которой его можно применять. В следующих статьях мы увидим,
        как можно применить этот алгоритм к другим структурам данных.
      </p>
    </>
  );
}

export default Backtracking;
