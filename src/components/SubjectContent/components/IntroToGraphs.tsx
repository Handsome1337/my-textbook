import graph from 'assets/graph.png?url';
import graphRepresentedByMatrix from 'assets/graph-represented-by-matrix.png?url';
import graphRepresentedByAdjacencyMatrix from 'assets/graph-represented-by-adjacency-matrix.png?url';
import graphRepresentedByAdjacencyList from 'assets/graph-represented-by-adjacency-list.png?url';
import { Code } from 'components/Code';
import type { ReactElement } from 'react';

const MATRIX = `const grid = [[0, 0, 0, 0],
              [1, 1, 0, 0],
              [0, 0, 0, 1],
              [0, 1, 0, 0]];`;

const ADJACENCY_MATRIX = `const adjMatrix = [[0, 0, 0, 0],
                   [1, 1, 0, 0],
                   [0, 0, 0, 1],
                   [0, 1, 0, 0]];`;

const ADJACENCY_MATRIX_CONCLUSION = `// ребро от v1 до v2 существует
adjMatrix[v1][v2] = 1;

// ребро от v2 до v1 существует
adjMatrix[v2][v1] = 1;

// рёбер от v1 до v2 не существует
adjMatrix[v1][v2] = 0;

// рёбер от v2 до v1 не существует
adjMatrix[v2][v1] = 0;`;

const GRAPH_NODE = `class GraphNode {
  constructor(val) {
    this.val = val;
    this.neighbors = [];
  }
}`;

function IntroToGraphs(): ReactElement {
  return (
    <>
      <p className="mb-2">
        На самом деле в ходе курса мы уже несколько раз встречались с графами. Граф — это
        структура данных, состоящая из узлов (которые мы видели в виде узлов дерева и
        узлов списка) и, возможно, указателей, соединяющих их вместе.
      </p>
      <p className="mb-2">Давайте сначала рассмотрим некоторую терминологию графов.</p>
      <h2 className="font-bold my-2">Терминология графов</h2>
      <p className="mb-2">
        В графах узлы называются <strong>вершинами</strong>, а указатели, соединяющие эти
        узлы, называются <strong>рёбрами</strong>. В графах нет ограничений относительно
        расположения узлов и того, как рёбра соединяют эти узлы вместе.
      </p>
      <p className="mb-2">
        Также возможно, что узлы не соединены никакими рёбрами, и это все равно будет
        считаться графом — пустым графом (нуль-графом).
      </p>
      <p className="mb-2">
        Число рёбер <code>E</code>, учитывая количество вершин <code>V</code>, всегда
        будет меньше или равно{' '}
        <code>
          V<sup>2</sup>
        </code>
        .{' '}
        <code>
          E &lt;= V<sup>2</sup>
        </code>
        . Это связано с тем, что каждый узел может указывать максимум на себя и на любой
        другой узел графа. Если у нас есть узлы <code>A</code>, <code>B</code> и{' '}
        <code>C</code>, <code>A</code> может указывать на себя, <code>B</code> и{' '}
        <code>C</code>. То же самое касается <code>B</code> и <code>C</code>.
      </p>
      <p className="mb-2">
        Если указатели, соединяющие рёбра, имеют направление, граф называется{' '}
        <strong>ориентированным графом</strong>. Если есть рёбра, но нет направления,
        такой граф называется <strong>неориентированным графом</strong>. Например, деревья
        и связные списки представляют собой ориентированные графы, поскольку у нас есть
        такие указатели, как <code>prev</code>, <code>next</code> и <code>left</code>,{' '}
        <code>right</code>.
      </p>
      <img alt="Граф" className="mb-2" height="320" src={graph} width="240" />
      <h2 className="font-bold my-2">Форматы графов</h2>
      <p className="mb-2">
        Граф можно представить по-разному. Это абстрактная концепция, которая
        конкретизируется с использованием различных структур данных. Чаще всего графы
        представляются с использованием следующего:
      </p>
      <ol className="list-decimal list-inside">
        <li className="mb-2">Матрица</li>
        <li className="mb-2">Матрица смежности</li>
        <li className="mb-2">Список смежности</li>
      </ol>
      <ul>
        <li className="mb-2">
          <strong>Матрица</strong>
          <p className="mb-2">
            Матрица — это двумерный массив со строками и столбцами, и граф можно
            представить с помощью матрицы. В приведённом ниже коде каждый массив,
            разделённый запятыми, представляет каждую строку. Здесь у нас четыре строки и
            четыре столбца. Все индексы начинаются с <code>0</code>, и идея состоит в том,
            что мы должны иметь возможность доступа к произвольной строке, столбцу или
            конкретному элементу по указанной строке или столбцу. Доступ ко второй строке
            можно легко выполнить с помощью <code>grid[1]</code>, а доступ ко второму
            столбцу можно выполнить с помощью <code>grid[0][1]</code>.
          </p>
          <Code value={MATRIX} />
          <p className="mb-2">
            Как это можно использовать для представления графа? Как мы уже упоминали,
            графы абстрактны и могут быть определены разными способами. Допустим, все нули
            в нашей сетке являются вершинами. Чтобы пройти по графу, нам разрешено
            двигаться вверх, вниз, влево и вправо. Если мы хотим соединить нули вместе,
            используя наши рёбра, мы в конечном итоге получим кучу связанных нулей,
            которые являются связанными компонентами, обозначающими граф. Мы обсудим обход
            матрицы в следующей статье.
          </p>
          <img
            alt="Граф представленный с помощью матрицы"
            className="mb-2"
            height="260"
            src={graphRepresentedByMatrix}
            width="440"
          />
        </li>
        <li className="mb-2">
          <strong>Матрица смежности</strong>
          <p className="mb-2">
            Это менее распространенный формат ввода. Здесь индекс массива представляет
            саму вершину. Давайте возьмем пример:
          </p>
          <Code value={ADJACENCY_MATRIX} />
          <p className="mb-2">
            Поскольку индексы сами по себе представляют вершину, <code>0</code> означает,
            что ребро не существует между заданными <code>v1, v2</code> и <code>1</code>{' '}
            означает обратное. <code>adjMatrix[1][2] === 0</code> означает, что между
            вершинами <code>1</code> и <code>2</code> нет ребра. Кроме того,{' '}
            <code>adjMatrix[2][1] === 0</code> означает, что между вершинами{' '}
            <code>2</code> и <code>1</code> нет ребра. Из этого можно сделать следующий
            вывод:
          </p>
          <Code value={ADJACENCY_MATRIX_CONCLUSION} />
          <p className="mb-2">
            Чтобы представить приведённую выше матрицу смежности, мы можем взглянуть на
            следующее изображение.
          </p>
          <img
            alt="Граф представленный с помощью матрицы смежности"
            className="mb-2"
            height="260"
            src={graphRepresentedByAdjacencyMatrix}
            width="520"
          />
          <p className="mb-2">
            Проблема в том, что это гигантский расход памяти. Поскольку это квадратная
            матрица, сложность по времени равна <i>O</i>(V<sup>2</sup>), где{' '}
            <code>V</code> — количество вершин. Это имеет смысл, поскольку количество
            рёбер также равно количеству узлов.
          </p>
        </li>
        <li className="mb-2">
          <strong>Список смежности</strong>
          <p className="mb-2">
            Обычно это наиболее распространенный способ представления графов. Это также
            двумерный массив. Удобство здесь в том, что мы можем объявить его, используя
            класс <code>GraphNode</code>, и он содержит атрибут списка, называемый{' '}
            <code>neighbors</code>, с помощью которого мы можем получить доступ ко всем
            соседям данной вершины.
          </p>
          <Code value={GRAPH_NODE} />
          <p className="mb-2">
            В конечном итоге это обеспечивает более эффективное использование памяти,
            поскольку нас интересуют только связанные узлы.
          </p>
          <img
            alt="Граф представленный с помощью списка смежности"
            className="mb-2"
            height="180"
            src={graphRepresentedByAdjacencyList}
            width="280"
          />
        </li>
      </ul>
      <p className="mb-2">
        В следующих нескольких статьях мы обсудим, как мы можем выполнять обход графа,
        используя все вышеупомянутые форматы, и какие проблемы мы можем решить с помощью
        графов.
      </p>
    </>
  );
}

export default IntroToGraphs;
