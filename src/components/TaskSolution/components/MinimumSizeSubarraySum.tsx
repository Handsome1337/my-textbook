import type { ReactElement } from 'react';

function MinimumSizeSubarraySum(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Для решения этой задачи будем использовать метод скользящего окна. Создадим
        переменные <code>currentSum</code> и <code>l</code> со значением 0, и{' '}
        <code>result</code> со значением <code>Infinity</code> (можно использовать{' '}
        <code>nums.length + 1</code>, изначальное значение должно быть больше возможного
        подмассива. Во время прохождения по массиву мы будем перезаписывать это значение,
        когда встретим подходящий подмассив. Если мы ни разу не встретим такой подмассив,
        по начальному значению мы поймём, что должны вернуть <code>0</code>).
      </p>
      <p className="mb-2">
        Пройдём циклом по массиву. На каждой итерации добавляем текущее число к сумме. Во
        внутреннем цикле <code>while</code>, если сумма больше или равна{' '}
        <code>target</code>, то обновляем <code>result</code>, присваивая минимальное
        значение между <code>result</code> и размером текущего окна (
        <code>r - l + 1</code>), после чего отнимаем из суммы число, на которое указывает
        левый указатель, и передвигаем <code>l</code>.
      </p>
      <p className="mb-2">
        Цикл <code>while</code> не выполняет <i>n</i> итераций на каждой итерации цикла{' '}
        <code>for</code>, он выполнит <i>n</i> итераций всего. Поэтому цикл в цикле не
        приведёт к сложности по времени <i>O</i>(<i>n</i>
        <sup>2</sup>).
      </p>
      <p className="mb-2">
        Если после прохождения цикла <code>for</code> в <code>result</code> осталось
        значение <code>Infinity</code>, то это означает, что искомого подмассива не
        существует, возвращаем <code>0</code>. Иначе возвращаем <code>result</code>.
      </p>
    </>
  );
}

export default MinimumSizeSubarraySum;
