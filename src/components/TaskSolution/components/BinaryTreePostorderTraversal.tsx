import { Link } from 'react-router-dom';
import type { ReactElement } from 'react';

function BinaryTreePostorderTraversal(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Обход по дереву проще всего выполнять с помощью рекурсии, однако такой обход мы
        уже рассмотрели в нашей{' '}
        <Link
          to="/subjects/depth-first-search"
          className="focus-visible:font-semibold focus-visible:outline-0 hover:font-semibold text-blue-500"
        >
          статье
        </Link>
        . Рассмотрим итеративное решение этой задачи.
      </p>
      <p className="mb-2">
        Для решения задачи нам понадобится стек. Создадим его и массив <code>result</code>
        , который мы будем возвращать из функции. Нам понадобится два раза пройти по
        каждому узлу, чтобы мы смогли добавить значения в <code>result</code> в корректном
        порядке. Чтобы понимать, в первый ли раз мы посещаем узел, будем сохранять в стеке
        не только узел, но и флаг <code>visited</code>, который будет равен{' '}
        <code>false</code>, если мы посетили узел в первый раз, и <code>true</code>, если
        во второй. Добавим корневой узел в стек.
      </p>
      <p className="mb-2">
        Создадим цикл <code>while</code>, который будет исполняться, пока в стеке есть
        узлы. На каждой итерации достаём из стека последний элемент. Если этот элемент
        равен <code>null</code>, то нам ничего не надо с ним делать, необходимо достать
        следующий элемент из стека — это произойдёт само собой на следующей итерации
        цикла. Если мы достали из стека узел, то проверяем, посещали ли мы его ранее. Если
        посещали, то добавляем его значение в <code>result</code>. Иначе добавляем этот же
        узел в стек с флагом <code>visited: true</code>, после чего добавляем в стек его
        правый и левый дочерние узлы.
      </p>
      <p className="mb-2">
        На следующей итерации мы достанем последний элемент из стека, который будет
        указывать на левый дочерний узел и иметь <code>visited: false</code>. Мы не должны
        добавлять его в <code>result</code>, пока мы не обработаем его дочерние узлы.
        Именно поэтому нам необходимо посещать каждый узел дважды и иметь флаг посещения.
        Когда мы посетим все дочерние узлы, мы опять вернёмся к этому узлу, и так как{' '}
        <code>visited</code> будет равно <code>true</code>, мы добавим его значение в{' '}
        <code>result</code>.
      </p>
      <p className="mb-2">
        В результате порядок обхода узлов получится таким же, как при рекурсивном
        Postorder обходе.
      </p>
    </>
  );
}

export default BinaryTreePostorderTraversal;
