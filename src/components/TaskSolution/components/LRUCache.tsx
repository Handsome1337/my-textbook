import type { ReactElement } from 'react';

function LRUCache(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Для решения этой задачи будем использовать{' '}
        <a
          className="focus-visible:outline-0 focus-visible:underline hover:underline text-blue-500"
          href="https://ru.wikipedia.org/wiki/Связный_список#Двусвязный_список_(двунаправленный_связный_список)"
          rel="noreferrer"
          target="_blank"
        >
          двусвязный список
        </a>
        . Создадим класс <code>Node</code> для узла списка. Каждый узел будет содержать в
        себе <code>key</code> и <code>value</code>.
      </p>
      <p className="mb-2">
        В конструкторе класса <code>LRUCache</code> создадим объект <code>Map</code>,
        который будет содержать в себе коллекцию ключ/узел. Также создадим два фиктивных
        узла, которые являются указателями на значение, которое дольше всего не
        запрашивалось (<code>this.left</code>), и последнее запрашиваемое (
        <code>this.right</code>) значения. Свяжем их, чтобы добавлять новые значения между
        ними.
      </p>
      <p className="mb-2">
        Добавим вспомогательные методы <code>remove</code> и <code>insert</code>. Метод{' '}
        <code>remove</code> будет удалять узел из списка, <code>insert</code> — вставлять
        узел в конец списка.
      </p>
      <p className="mb-2">
        В методе <code>get</code> мы проверяем, есть ли узел с таким ключом. Если есть, то
        удаляем его из списка и вставляем заново. Таким образом, узел окажется в конце
        списка (на него будет указывать <code>this.right.prev</code>, а значит, в данный
        момент это последний запрашиваемый узел). Возвращаем <code>value</code> этого
        узла. Иначе возвращаем <code>-1</code>.
      </p>
      <p className="mb-2">
        В методе <code>put</code> мы проверяем, есть ли узел с таким ключом. Если есть, то
        удаляем его из списка. Создадим новый узел, добавим его в кэш и список. Узел так
        же, как и в случае с <code>get</code>, окажется в конце списка. Затем проверим
        размер кэша, и если он превысил допустимый размер, то удалим узел, который дольше
        всего не запрашивался.
      </p>
    </>
  );
}

export default LRUCache;
