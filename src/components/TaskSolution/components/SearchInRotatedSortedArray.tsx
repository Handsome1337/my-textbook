import type { ReactElement } from 'react';

function SearchInRotatedSortedArray(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Создадим два указателя <code>left</code> и <code>right</code>, которые будут
        указывать на первое и последнее число в массиве. Пройдём бинарным поиском по
        массиву.
      </p>
      <p className="mb-2">
        На каждой итерации проверяем, нашли ли мы искомое значение{' '}
        <code>target === nums[middle]</code>. Если нашли, то возвращаем из функции его
        индекс. Если <code>nums[left] &lt;= nums[middle]</code>, то слева находится
        отсортированная часть массива. Если <code>target</code> больше, чем самое большое
        число в этой части <code>nums[middle]</code>, или если <code>target</code> меньше,
        чем самое маленькое число в этой части <code>nums[left]</code>, то искать значение
        нам надо в правой части, перемещаем левый указатель вправо. Если оба условия не
        выполняются, это означет, что искомое число находится в левой части массива, и мы
        просто перемещаем правый указатель влево, как при обычном бинарном поиске.
      </p>
      <p className="mb-2">
        Если же левая часть не отсортирована, то это означает, что правая часть
        отсортирована. Если <code>target</code> меньше, чем самое маленькое число в правой
        части <code>nums[middle]</code>, или если <code>target</code> больше, чем самое
        большое число в правой части <code>nums[right]</code>, то искать значение нам надо
        в левой части, перемещаем правый указатель влево. Если оба условия не выполняются,
        это означет, что искомое число находится в правой части масса, и мы просто
        перемещаем левый указатель вправо, как при обычном бинарном поиске.
      </p>
      <p className="mb-2">
        Если цикл закончился, то это означает, что искомого числа нет в массиве,
        возвращаем <code>-1</code>.
      </p>
    </>
  );
}

export default SearchInRotatedSortedArray;
