import { Link } from 'react-router-dom';
import type { ReactElement } from 'react';

function SortColors(): ReactElement {
  return (
    <>
      <p className="mb-2">
        Для решения этой задачи отлично подходит алгоритм блочной сортировки, но для
        такого решения понадобится два прохода по массиву. Мы рассмотрим решение, в
        котором мы обойдёмся одним проходом по массиву. Решение с помощью блочной
        сортировки можно посмотреть{' '}
        <Link
          to="/subjects/bucket-sort"
          className="focus-visible:font-semibold focus-visible:outline-0 hover:font-semibold text-blue-500"
        >
          тут
        </Link>
        .
      </p>
      <p className="mb-2">
        Мы знаем, что в нашем массиве есть только 3 варианта значений: <code>0</code>,{' '}
        <code>1</code> и <code>2</code>. Это означает, что мы можем пройтись по массиву, и
        когда мы встречаем <code>0</code>, то переставлять его в левую часть массива, а
        когда встречаем <code>2</code>, то переставлять в правую часть массива. С{' '}
        <code>1</code> можно ничего не делать, потому что они должны остаться между{' '}
        <code>0</code> и <code>2</code>.
      </p>
      <p className="mb-2">
        Создадим 3 указателя: <code>left</code>, который будет указывать на первый элемент
        массива, <code>right</code>, который будет указывать на последний элемент массива,
        и <code>i</code>, указывающий на текущий элемент. Пройдём циклом по массиву, пока{' '}
        <code>i</code> не пересечёт <code>right</code> — это будет означать, что массив
        отсортирован. В конце каждой итерации будем перемещать указатель <code>i</code>.
      </p>
      <p className="mb-2">
        На каждой итерации проверяем, равен ли текущий элемент <code>0</code>. Если так,
        то переставим местами элементы <code>nums[left]</code> и <code>nums[i]</code>,
        после чего передвинем указатель <code>left</code> на одну позицию вправо. Это
        будет означать, что все элементы перед <code>left</code> являются нулями.
      </p>
      <p className="mb-2">
        Если текущий элемент равен <code>2</code>, то переставим местами элементы{' '}
        <code>nums[i]</code> и <code>nums[right]</code>, после чего передвинем указатель{' '}
        <code>right</code> на одну позицию влево. Это будет означать, что все элементы
        после <code>right</code> являются двойками. Однако в этом случае может получиться
        ситуация, когда мы переставили из <code>right</code> в <code>i</code> элемент,
        равный <code>0</code>, поэтому мы не должны двигать указатель <code>i</code>,
        чтобы не пропустить этот <code>0</code>. Так как в конце каждой итерации мы
        увеличиваем <code>i</code>, в нашем условии мы можем просто уменьшить{' '}
        <code>i</code>, чтобы в конце итерации получилось так, что наш указатель никуда не
        переместился.
      </p>
    </>
  );
}

export default SortColors;
